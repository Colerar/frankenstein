use crate::objects::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum InlineQueryResult {
    InlineQueryResultCachedAudioVariant(InlineQueryResultCachedAudio),
    InlineQueryResultCachedDocumentVariant(InlineQueryResultCachedDocument),
    InlineQueryResultCachedGifVariant(InlineQueryResultCachedGif),
    InlineQueryResultCachedMpeg4GifVariant(InlineQueryResultCachedMpeg4Gif),
    InlineQueryResultCachedPhotoVariant(InlineQueryResultCachedPhoto),
    InlineQueryResultCachedStickerVariant(InlineQueryResultCachedSticker),
    InlineQueryResultCachedVideoVariant(InlineQueryResultCachedVideo),
    InlineQueryResultCachedVoiceVariant(InlineQueryResultCachedVoice),
    InlineQueryResultArticleVariant(InlineQueryResultArticle),
    InlineQueryResultAudioVariant(InlineQueryResultAudio),
    InlineQueryResultContactVariant(InlineQueryResultContact),
    InlineQueryResultGameVariant(InlineQueryResultGame),
    InlineQueryResultDocumentVariant(InlineQueryResultDocument),
    InlineQueryResultGifVariant(InlineQueryResultGif),
    InlineQueryResultLocationVariant(InlineQueryResultLocation),
    InlineQueryResultMpeg4GifVariant(InlineQueryResultMpeg4Gif),
    InlineQueryResultPhotoVariant(InlineQueryResultPhoto),
    InlineQueryResultVenueVariant(InlineQueryResultVenue),
    InlineQueryResultVideoVariant(InlineQueryResultVideo),
    InlineQueryResultVoiceVariant(InlineQueryResultVoice),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum InputMedia {
    InputMediaAnimationVariant(InputMediaAnimation),
    InputMediaDocumentVariant(InputMediaDocument),
    InputMediaAudioVariant(InputMediaAudio),
    InputMediaPhotoVariant(InputMediaPhoto),
    InputMediaVideoVariant(InputMediaVideo),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum PassportElementError {
    PassportElementErrorDataFieldVariant(PassportElementErrorDataField),
    PassportElementErrorFrontSideVariant(PassportElementErrorFrontSide),
    PassportElementErrorReverseSideVariant(PassportElementErrorReverseSide),
    PassportElementErrorSelfieVariant(PassportElementErrorSelfie),
    PassportElementErrorFileVariant(PassportElementErrorFile),
    PassportElementErrorFilesVariant(PassportElementErrorFiles),
    PassportElementErrorTranslationFileVariant(PassportElementErrorTranslationFile),
    PassportElementErrorTranslationFilesVariant(PassportElementErrorTranslationFiles),
    PassportElementErrorUnspecifiedVariant(PassportElementErrorUnspecified),
}

// All structs and functions below are autogenerated with frankenstein_creator
// https://github.com/ayrat555/frankenstein_creator

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum ChatIdEnum {
    IsizeVariant(isize),
    StringVariant(String),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum ReplyMarkupEnum {
    InlineKeyboardMarkupVariant(InlineKeyboardMarkup),
    ReplyKeyboardMarkupVariant(ReplyKeyboardMarkup),
    ReplyKeyboardRemoveVariant(ReplyKeyboardRemove),
    ForceReplyVariant(ForceReply),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum FromChatIdEnum {
    IsizeVariant(isize),
    StringVariant(String),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum PhotoEnum {
    InputFileVariant(InputFile),
    StringVariant(String),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum AudioEnum {
    InputFileVariant(InputFile),
    StringVariant(String),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum ThumbEnum {
    InputFileVariant(InputFile),
    StringVariant(String),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum DocumentEnum {
    InputFileVariant(InputFile),
    StringVariant(String),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum VideoEnum {
    InputFileVariant(InputFile),
    StringVariant(String),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum AnimationEnum {
    InputFileVariant(InputFile),
    StringVariant(String),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum VoiceEnum {
    InputFileVariant(InputFile),
    StringVariant(String),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum VideoNoteEnum {
    InputFileVariant(InputFile),
    StringVariant(String),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum MediaEnum {
    InputMediaAudioVariant(InputMediaAudio),
    InputMediaDocumentVariant(InputMediaDocument),
    InputMediaPhotoVariant(InputMediaPhoto),
    InputMediaVideoVariant(InputMediaVideo),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum StickerEnum {
    InputFileVariant(InputFile),
    StringVariant(String),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum PngStickerEnum {
    InputFileVariant(InputFile),
    StringVariant(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetUpdatesParams {
    offset: Option<isize>,
    limit: Option<isize>,
    timeout: Option<isize>,
    allowed_updates: Option<Vec<String>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetWebhookParams {
    url: String,
    certificate: Option<InputFile>,
    ip_address: Option<String>,
    max_connections: Option<isize>,
    allowed_updates: Option<Vec<String>>,
    drop_pending_updates: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteWebhookParams {
    drop_pending_updates: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendMessageParams {
    chat_id: ChatIdEnum,
    text: String,
    parse_mode: Option<String>,
    entities: Option<Vec<MessageEntity>>,
    disable_web_page_preview: Option<bool>,
    disable_notification: Option<bool>,
    reply_to_message_id: Option<isize>,
    allow_sending_without_reply: Option<bool>,
    reply_markup: Option<ReplyMarkupEnum>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ForwardMessageParams {
    chat_id: ChatIdEnum,
    from_chat_id: FromChatIdEnum,
    disable_notification: Option<bool>,
    message_id: isize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CopyMessageParams {
    chat_id: ChatIdEnum,
    from_chat_id: FromChatIdEnum,
    message_id: isize,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    disable_notification: Option<bool>,
    reply_to_message_id: Option<isize>,
    allow_sending_without_reply: Option<bool>,
    reply_markup: Option<ReplyMarkupEnum>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendPhotoParams {
    chat_id: ChatIdEnum,
    photo: PhotoEnum,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    disable_notification: Option<bool>,
    reply_to_message_id: Option<isize>,
    allow_sending_without_reply: Option<bool>,
    reply_markup: Option<ReplyMarkupEnum>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendAudioParams {
    chat_id: ChatIdEnum,
    audio: AudioEnum,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    duration: Option<isize>,
    performer: Option<String>,
    title: Option<String>,
    thumb: Option<ThumbEnum>,
    disable_notification: Option<bool>,
    reply_to_message_id: Option<isize>,
    allow_sending_without_reply: Option<bool>,
    reply_markup: Option<ReplyMarkupEnum>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendDocumentParams {
    chat_id: ChatIdEnum,
    document: DocumentEnum,
    thumb: Option<ThumbEnum>,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    disable_content_type_detection: Option<bool>,
    disable_notification: Option<bool>,
    reply_to_message_id: Option<isize>,
    allow_sending_without_reply: Option<bool>,
    reply_markup: Option<ReplyMarkupEnum>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendVideoParams {
    chat_id: ChatIdEnum,
    video: VideoEnum,
    duration: Option<isize>,
    width: Option<isize>,
    height: Option<isize>,
    thumb: Option<ThumbEnum>,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    supports_streaming: Option<bool>,
    disable_notification: Option<bool>,
    reply_to_message_id: Option<isize>,
    allow_sending_without_reply: Option<bool>,
    reply_markup: Option<ReplyMarkupEnum>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendAnimationParams {
    chat_id: ChatIdEnum,
    animation: AnimationEnum,
    duration: Option<isize>,
    width: Option<isize>,
    height: Option<isize>,
    thumb: Option<ThumbEnum>,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    disable_notification: Option<bool>,
    reply_to_message_id: Option<isize>,
    allow_sending_without_reply: Option<bool>,
    reply_markup: Option<ReplyMarkupEnum>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendVoiceParams {
    chat_id: ChatIdEnum,
    voice: VoiceEnum,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    duration: Option<isize>,
    disable_notification: Option<bool>,
    reply_to_message_id: Option<isize>,
    allow_sending_without_reply: Option<bool>,
    reply_markup: Option<ReplyMarkupEnum>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendVideoNoteParams {
    chat_id: ChatIdEnum,
    video_note: VideoNoteEnum,
    duration: Option<isize>,
    length: Option<isize>,
    thumb: Option<ThumbEnum>,
    disable_notification: Option<bool>,
    reply_to_message_id: Option<isize>,
    allow_sending_without_reply: Option<bool>,
    reply_markup: Option<ReplyMarkupEnum>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendMediaGroupParams {
    chat_id: ChatIdEnum,
    media: Vec<MediaEnum>,
    disable_notification: Option<bool>,
    reply_to_message_id: Option<isize>,
    allow_sending_without_reply: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendLocationParams {
    chat_id: ChatIdEnum,
    latitude: f64,
    longitude: f64,
    horizontal_accuracy: Option<f64>,
    live_period: Option<isize>,
    heading: Option<isize>,
    proximity_alert_radius: Option<isize>,
    disable_notification: Option<bool>,
    reply_to_message_id: Option<isize>,
    allow_sending_without_reply: Option<bool>,
    reply_markup: Option<ReplyMarkupEnum>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EditMessageLiveLocationParams {
    chat_id: Option<ChatIdEnum>,
    message_id: Option<isize>,
    inline_message_id: Option<String>,
    latitude: f64,
    longitude: f64,
    horizontal_accuracy: Option<f64>,
    heading: Option<isize>,
    proximity_alert_radius: Option<isize>,
    reply_markup: Option<InlineKeyboardMarkup>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StopMessageLiveLocationParams {
    chat_id: Option<ChatIdEnum>,
    message_id: Option<isize>,
    inline_message_id: Option<String>,
    reply_markup: Option<InlineKeyboardMarkup>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendVenueParams {
    chat_id: ChatIdEnum,
    latitude: f64,
    longitude: f64,
    title: String,
    address: String,
    foursquare_id: Option<String>,
    foursquare_type: Option<String>,
    google_place_id: Option<String>,
    google_place_type: Option<String>,
    disable_notification: Option<bool>,
    reply_to_message_id: Option<isize>,
    allow_sending_without_reply: Option<bool>,
    reply_markup: Option<ReplyMarkupEnum>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendContactParams {
    chat_id: ChatIdEnum,
    phone_number: String,
    first_name: String,
    last_name: Option<String>,
    vcard: Option<String>,
    disable_notification: Option<bool>,
    reply_to_message_id: Option<isize>,
    allow_sending_without_reply: Option<bool>,
    reply_markup: Option<ReplyMarkupEnum>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendPollParams {
    chat_id: ChatIdEnum,
    question: String,
    options: Vec<String>,
    is_anonymous: Option<bool>,
    type_field: Option<String>,
    allows_multiple_answers: Option<bool>,
    correct_option_id: Option<isize>,
    explanation: Option<String>,
    explanation_parse_mode: Option<String>,
    explanation_entities: Option<Vec<MessageEntity>>,
    open_period: Option<isize>,
    close_date: Option<isize>,
    is_closed: Option<bool>,
    disable_notification: Option<bool>,
    reply_to_message_id: Option<isize>,
    allow_sending_without_reply: Option<bool>,
    reply_markup: Option<ReplyMarkupEnum>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendDiceParams {
    chat_id: ChatIdEnum,
    emoji: Option<String>,
    disable_notification: Option<bool>,
    reply_to_message_id: Option<isize>,
    allow_sending_without_reply: Option<bool>,
    reply_markup: Option<ReplyMarkupEnum>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendChatActionParams {
    chat_id: ChatIdEnum,
    action: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetUserProfilePhotosParams {
    user_id: isize,
    offset: Option<isize>,
    limit: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetFileParams {
    file_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KickChatMemberParams {
    chat_id: ChatIdEnum,
    user_id: isize,
    until_date: Option<isize>,
    revoke_messages: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UnbanChatMemberParams {
    chat_id: ChatIdEnum,
    user_id: isize,
    only_if_banned: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RestrictChatMemberParams {
    chat_id: ChatIdEnum,
    user_id: isize,
    permissions: ChatPermissions,
    until_date: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PromoteChatMemberParams {
    chat_id: ChatIdEnum,
    user_id: isize,
    is_anonymous: Option<bool>,
    can_manage_chat: Option<bool>,
    can_post_messages: Option<bool>,
    can_edit_messages: Option<bool>,
    can_delete_messages: Option<bool>,
    can_manage_voice_chats: Option<bool>,
    can_restrict_members: Option<bool>,
    can_promote_members: Option<bool>,
    can_change_info: Option<bool>,
    can_invite_users: Option<bool>,
    can_pin_messages: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetChatAdministratorCustomTitleParams {
    chat_id: ChatIdEnum,
    user_id: isize,
    custom_title: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetChatPermissionsParams {
    chat_id: ChatIdEnum,
    permissions: ChatPermissions,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExportChatInviteLinkParams {
    chat_id: ChatIdEnum,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateChatInviteLinkParams {
    chat_id: ChatIdEnum,
    expire_date: Option<isize>,
    member_limit: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EditChatInviteLinkParams {
    chat_id: ChatIdEnum,
    invite_link: String,
    expire_date: Option<isize>,
    member_limit: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RevokeChatInviteLinkParams {
    chat_id: ChatIdEnum,
    invite_link: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetChatPhotoParams {
    chat_id: ChatIdEnum,
    photo: InputFile,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteChatPhotoParams {
    chat_id: ChatIdEnum,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetChatTitleParams {
    chat_id: ChatIdEnum,
    title: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetChatDescriptionParams {
    chat_id: ChatIdEnum,
    description: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PinChatMessageParams {
    chat_id: ChatIdEnum,
    message_id: isize,
    disable_notification: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UnpinChatMessageParams {
    chat_id: ChatIdEnum,
    message_id: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UnpinAllChatMessagesParams {
    chat_id: ChatIdEnum,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LeaveChatParams {
    chat_id: ChatIdEnum,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatParams {
    chat_id: ChatIdEnum,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatAdministratorsParams {
    chat_id: ChatIdEnum,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatMembersCountParams {
    chat_id: ChatIdEnum,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatMemberParams {
    chat_id: ChatIdEnum,
    user_id: isize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetChatStickerSetParams {
    chat_id: ChatIdEnum,
    sticker_set_name: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteChatStickerSetParams {
    chat_id: ChatIdEnum,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnswerCallbackQueryParams {
    callback_query_id: String,
    text: Option<String>,
    show_alert: Option<bool>,
    url: Option<String>,
    cache_time: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetMyCommandsParams {
    commands: Vec<BotCommand>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EditMessageTextParams {
    chat_id: Option<ChatIdEnum>,
    message_id: Option<isize>,
    inline_message_id: Option<String>,
    text: String,
    parse_mode: Option<String>,
    entities: Option<Vec<MessageEntity>>,
    disable_web_page_preview: Option<bool>,
    reply_markup: Option<InlineKeyboardMarkup>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EditMessageCaptionParams {
    chat_id: Option<ChatIdEnum>,
    message_id: Option<isize>,
    inline_message_id: Option<String>,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    reply_markup: Option<InlineKeyboardMarkup>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EditMessageMediaParams {
    chat_id: Option<ChatIdEnum>,
    message_id: Option<isize>,
    inline_message_id: Option<String>,
    media: InputMedia,
    reply_markup: Option<InlineKeyboardMarkup>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EditMessageReplyMarkupParams {
    chat_id: Option<ChatIdEnum>,
    message_id: Option<isize>,
    inline_message_id: Option<String>,
    reply_markup: Option<InlineKeyboardMarkup>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StopPollParams {
    chat_id: ChatIdEnum,
    message_id: isize,
    reply_markup: Option<InlineKeyboardMarkup>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteMessageParams {
    chat_id: ChatIdEnum,
    message_id: isize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendStickerParams {
    chat_id: ChatIdEnum,
    sticker: StickerEnum,
    disable_notification: Option<bool>,
    reply_to_message_id: Option<isize>,
    allow_sending_without_reply: Option<bool>,
    reply_markup: Option<ReplyMarkupEnum>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetStickerSetParams {
    name: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UploadStickerFileParams {
    user_id: isize,
    png_sticker: InputFile,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateNewStickerSetParams {
    user_id: isize,
    name: String,
    title: String,
    png_sticker: Option<PngStickerEnum>,
    tgs_sticker: Option<InputFile>,
    emojis: String,
    contains_masks: Option<bool>,
    mask_position: Option<MaskPosition>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddStickerToSetParams {
    user_id: isize,
    name: String,
    png_sticker: Option<PngStickerEnum>,
    tgs_sticker: Option<InputFile>,
    emojis: String,
    mask_position: Option<MaskPosition>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetStickerPositionInSetParams {
    sticker: String,
    position: isize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteStickerFromSetParams {
    sticker: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetStickerSetThumbParams {
    name: String,
    user_id: isize,
    thumb: Option<ThumbEnum>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnswerInlineQueryParams {
    inline_query_id: String,
    results: Vec<InlineQueryResult>,
    cache_time: Option<isize>,
    is_personal: Option<bool>,
    next_offset: Option<String>,
    switch_pm_text: Option<String>,
    switch_pm_parameter: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendInvoiceParams {
    chat_id: isize,
    title: String,
    description: String,
    payload: String,
    provider_token: String,
    start_parameter: String,
    currency: String,
    prices: Vec<LabeledPrice>,
    provider_data: Option<String>,
    photo_url: Option<String>,
    photo_size: Option<isize>,
    photo_width: Option<isize>,
    photo_height: Option<isize>,
    need_name: Option<bool>,
    need_phone_number: Option<bool>,
    need_email: Option<bool>,
    need_shipping_address: Option<bool>,
    send_phone_number_to_provider: Option<bool>,
    send_email_to_provider: Option<bool>,
    is_flexible: Option<bool>,
    disable_notification: Option<bool>,
    reply_to_message_id: Option<isize>,
    allow_sending_without_reply: Option<bool>,
    reply_markup: Option<InlineKeyboardMarkup>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnswerShippingQueryParams {
    shipping_query_id: String,
    ok: bool,
    shipping_options: Option<Vec<ShippingOption>>,
    error_message: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnswerPreCheckoutQueryParams {
    pre_checkout_query_id: String,
    ok: bool,
    error_message: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetPassportDataErrorsParams {
    user_id: isize,
    errors: Vec<PassportElementError>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendGameParams {
    chat_id: isize,
    game_short_name: String,
    disable_notification: Option<bool>,
    reply_to_message_id: Option<isize>,
    allow_sending_without_reply: Option<bool>,
    reply_markup: Option<InlineKeyboardMarkup>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetGameScoreParams {
    user_id: isize,
    score: isize,
    force: Option<bool>,
    disable_edit_message: Option<bool>,
    chat_id: Option<isize>,
    message_id: Option<isize>,
    inline_message_id: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetGameHighScoresParams {
    user_id: isize,
    chat_id: Option<isize>,
    message_id: Option<isize>,
    inline_message_id: Option<String>,
}

impl GetUpdatesParams {
    pub fn new() -> Self {
        Self {
            offset: None,
            limit: None,
            timeout: None,
            allowed_updates: None,
        }
    }

    pub fn offset(&mut self, offset: Option<isize>) {
        self.offset = offset;
    }

    pub fn limit(&mut self, limit: Option<isize>) {
        self.limit = limit;
    }

    pub fn timeout(&mut self, timeout: Option<isize>) {
        self.timeout = timeout;
    }

    pub fn allowed_updates(&mut self, allowed_updates: Option<Vec<String>>) {
        self.allowed_updates = allowed_updates;
    }
}

impl SetWebhookParams {
    pub fn new(url: String) -> Self {
        Self {
            url,
            certificate: None,
            ip_address: None,
            max_connections: None,
            allowed_updates: None,
            drop_pending_updates: None,
        }
    }

    pub fn url(&mut self, url: String) {
        self.url = url;
    }

    pub fn certificate(&mut self, certificate: Option<InputFile>) {
        self.certificate = certificate;
    }

    pub fn ip_address(&mut self, ip_address: Option<String>) {
        self.ip_address = ip_address;
    }

    pub fn max_connections(&mut self, max_connections: Option<isize>) {
        self.max_connections = max_connections;
    }

    pub fn allowed_updates(&mut self, allowed_updates: Option<Vec<String>>) {
        self.allowed_updates = allowed_updates;
    }

    pub fn drop_pending_updates(&mut self, drop_pending_updates: Option<bool>) {
        self.drop_pending_updates = drop_pending_updates;
    }
}

impl DeleteWebhookParams {
    pub fn new() -> Self {
        Self {
            drop_pending_updates: None,
        }
    }

    pub fn drop_pending_updates(&mut self, drop_pending_updates: Option<bool>) {
        self.drop_pending_updates = drop_pending_updates;
    }
}

impl SendMessageParams {
    pub fn new(chat_id: ChatIdEnum, text: String) -> Self {
        Self {
            chat_id,
            text,
            parse_mode: None,
            entities: None,
            disable_web_page_preview: None,
            disable_notification: None,
            reply_to_message_id: None,
            allow_sending_without_reply: None,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn text(&mut self, text: String) {
        self.text = text;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn entities(&mut self, entities: Option<Vec<MessageEntity>>) {
        self.entities = entities;
    }

    pub fn disable_web_page_preview(&mut self, disable_web_page_preview: Option<bool>) {
        self.disable_web_page_preview = disable_web_page_preview;
    }

    pub fn disable_notification(&mut self, disable_notification: Option<bool>) {
        self.disable_notification = disable_notification;
    }

    pub fn reply_to_message_id(&mut self, reply_to_message_id: Option<isize>) {
        self.reply_to_message_id = reply_to_message_id;
    }

    pub fn allow_sending_without_reply(&mut self, allow_sending_without_reply: Option<bool>) {
        self.allow_sending_without_reply = allow_sending_without_reply;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<ReplyMarkupEnum>) {
        self.reply_markup = reply_markup;
    }
}

impl ForwardMessageParams {
    pub fn new(chat_id: ChatIdEnum, from_chat_id: FromChatIdEnum, message_id: isize) -> Self {
        Self {
            chat_id,
            from_chat_id,
            message_id,
            disable_notification: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn from_chat_id(&mut self, from_chat_id: FromChatIdEnum) {
        self.from_chat_id = from_chat_id;
    }

    pub fn message_id(&mut self, message_id: isize) {
        self.message_id = message_id;
    }

    pub fn disable_notification(&mut self, disable_notification: Option<bool>) {
        self.disable_notification = disable_notification;
    }
}

impl CopyMessageParams {
    pub fn new(chat_id: ChatIdEnum, from_chat_id: FromChatIdEnum, message_id: isize) -> Self {
        Self {
            chat_id,
            from_chat_id,
            message_id,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            disable_notification: None,
            reply_to_message_id: None,
            allow_sending_without_reply: None,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn from_chat_id(&mut self, from_chat_id: FromChatIdEnum) {
        self.from_chat_id = from_chat_id;
    }

    pub fn message_id(&mut self, message_id: isize) {
        self.message_id = message_id;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn disable_notification(&mut self, disable_notification: Option<bool>) {
        self.disable_notification = disable_notification;
    }

    pub fn reply_to_message_id(&mut self, reply_to_message_id: Option<isize>) {
        self.reply_to_message_id = reply_to_message_id;
    }

    pub fn allow_sending_without_reply(&mut self, allow_sending_without_reply: Option<bool>) {
        self.allow_sending_without_reply = allow_sending_without_reply;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<ReplyMarkupEnum>) {
        self.reply_markup = reply_markup;
    }
}

impl SendPhotoParams {
    pub fn new(chat_id: ChatIdEnum, photo: PhotoEnum) -> Self {
        Self {
            chat_id,
            photo,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            disable_notification: None,
            reply_to_message_id: None,
            allow_sending_without_reply: None,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn photo(&mut self, photo: PhotoEnum) {
        self.photo = photo;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn disable_notification(&mut self, disable_notification: Option<bool>) {
        self.disable_notification = disable_notification;
    }

    pub fn reply_to_message_id(&mut self, reply_to_message_id: Option<isize>) {
        self.reply_to_message_id = reply_to_message_id;
    }

    pub fn allow_sending_without_reply(&mut self, allow_sending_without_reply: Option<bool>) {
        self.allow_sending_without_reply = allow_sending_without_reply;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<ReplyMarkupEnum>) {
        self.reply_markup = reply_markup;
    }
}

impl SendAudioParams {
    pub fn new(chat_id: ChatIdEnum, audio: AudioEnum) -> Self {
        Self {
            chat_id,
            audio,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            duration: None,
            performer: None,
            title: None,
            thumb: None,
            disable_notification: None,
            reply_to_message_id: None,
            allow_sending_without_reply: None,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn audio(&mut self, audio: AudioEnum) {
        self.audio = audio;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn duration(&mut self, duration: Option<isize>) {
        self.duration = duration;
    }

    pub fn performer(&mut self, performer: Option<String>) {
        self.performer = performer;
    }

    pub fn title(&mut self, title: Option<String>) {
        self.title = title;
    }

    pub fn thumb(&mut self, thumb: Option<ThumbEnum>) {
        self.thumb = thumb;
    }

    pub fn disable_notification(&mut self, disable_notification: Option<bool>) {
        self.disable_notification = disable_notification;
    }

    pub fn reply_to_message_id(&mut self, reply_to_message_id: Option<isize>) {
        self.reply_to_message_id = reply_to_message_id;
    }

    pub fn allow_sending_without_reply(&mut self, allow_sending_without_reply: Option<bool>) {
        self.allow_sending_without_reply = allow_sending_without_reply;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<ReplyMarkupEnum>) {
        self.reply_markup = reply_markup;
    }
}

impl SendDocumentParams {
    pub fn new(chat_id: ChatIdEnum, document: DocumentEnum) -> Self {
        Self {
            chat_id,
            document,
            thumb: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            disable_content_type_detection: None,
            disable_notification: None,
            reply_to_message_id: None,
            allow_sending_without_reply: None,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn document(&mut self, document: DocumentEnum) {
        self.document = document;
    }

    pub fn thumb(&mut self, thumb: Option<ThumbEnum>) {
        self.thumb = thumb;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn disable_content_type_detection(&mut self, disable_content_type_detection: Option<bool>) {
        self.disable_content_type_detection = disable_content_type_detection;
    }

    pub fn disable_notification(&mut self, disable_notification: Option<bool>) {
        self.disable_notification = disable_notification;
    }

    pub fn reply_to_message_id(&mut self, reply_to_message_id: Option<isize>) {
        self.reply_to_message_id = reply_to_message_id;
    }

    pub fn allow_sending_without_reply(&mut self, allow_sending_without_reply: Option<bool>) {
        self.allow_sending_without_reply = allow_sending_without_reply;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<ReplyMarkupEnum>) {
        self.reply_markup = reply_markup;
    }
}

impl SendVideoParams {
    pub fn new(chat_id: ChatIdEnum, video: VideoEnum) -> Self {
        Self {
            chat_id,
            video,
            duration: None,
            width: None,
            height: None,
            thumb: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            supports_streaming: None,
            disable_notification: None,
            reply_to_message_id: None,
            allow_sending_without_reply: None,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn video(&mut self, video: VideoEnum) {
        self.video = video;
    }

    pub fn duration(&mut self, duration: Option<isize>) {
        self.duration = duration;
    }

    pub fn width(&mut self, width: Option<isize>) {
        self.width = width;
    }

    pub fn height(&mut self, height: Option<isize>) {
        self.height = height;
    }

    pub fn thumb(&mut self, thumb: Option<ThumbEnum>) {
        self.thumb = thumb;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn supports_streaming(&mut self, supports_streaming: Option<bool>) {
        self.supports_streaming = supports_streaming;
    }

    pub fn disable_notification(&mut self, disable_notification: Option<bool>) {
        self.disable_notification = disable_notification;
    }

    pub fn reply_to_message_id(&mut self, reply_to_message_id: Option<isize>) {
        self.reply_to_message_id = reply_to_message_id;
    }

    pub fn allow_sending_without_reply(&mut self, allow_sending_without_reply: Option<bool>) {
        self.allow_sending_without_reply = allow_sending_without_reply;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<ReplyMarkupEnum>) {
        self.reply_markup = reply_markup;
    }
}

impl SendAnimationParams {
    pub fn new(chat_id: ChatIdEnum, animation: AnimationEnum) -> Self {
        Self {
            chat_id,
            animation,
            duration: None,
            width: None,
            height: None,
            thumb: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            disable_notification: None,
            reply_to_message_id: None,
            allow_sending_without_reply: None,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn animation(&mut self, animation: AnimationEnum) {
        self.animation = animation;
    }

    pub fn duration(&mut self, duration: Option<isize>) {
        self.duration = duration;
    }

    pub fn width(&mut self, width: Option<isize>) {
        self.width = width;
    }

    pub fn height(&mut self, height: Option<isize>) {
        self.height = height;
    }

    pub fn thumb(&mut self, thumb: Option<ThumbEnum>) {
        self.thumb = thumb;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn disable_notification(&mut self, disable_notification: Option<bool>) {
        self.disable_notification = disable_notification;
    }

    pub fn reply_to_message_id(&mut self, reply_to_message_id: Option<isize>) {
        self.reply_to_message_id = reply_to_message_id;
    }

    pub fn allow_sending_without_reply(&mut self, allow_sending_without_reply: Option<bool>) {
        self.allow_sending_without_reply = allow_sending_without_reply;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<ReplyMarkupEnum>) {
        self.reply_markup = reply_markup;
    }
}

impl SendVoiceParams {
    pub fn new(chat_id: ChatIdEnum, voice: VoiceEnum) -> Self {
        Self {
            chat_id,
            voice,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            duration: None,
            disable_notification: None,
            reply_to_message_id: None,
            allow_sending_without_reply: None,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn voice(&mut self, voice: VoiceEnum) {
        self.voice = voice;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn duration(&mut self, duration: Option<isize>) {
        self.duration = duration;
    }

    pub fn disable_notification(&mut self, disable_notification: Option<bool>) {
        self.disable_notification = disable_notification;
    }

    pub fn reply_to_message_id(&mut self, reply_to_message_id: Option<isize>) {
        self.reply_to_message_id = reply_to_message_id;
    }

    pub fn allow_sending_without_reply(&mut self, allow_sending_without_reply: Option<bool>) {
        self.allow_sending_without_reply = allow_sending_without_reply;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<ReplyMarkupEnum>) {
        self.reply_markup = reply_markup;
    }
}

impl SendVideoNoteParams {
    pub fn new(chat_id: ChatIdEnum, video_note: VideoNoteEnum) -> Self {
        Self {
            chat_id,
            video_note,
            duration: None,
            length: None,
            thumb: None,
            disable_notification: None,
            reply_to_message_id: None,
            allow_sending_without_reply: None,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn video_note(&mut self, video_note: VideoNoteEnum) {
        self.video_note = video_note;
    }

    pub fn duration(&mut self, duration: Option<isize>) {
        self.duration = duration;
    }

    pub fn length(&mut self, length: Option<isize>) {
        self.length = length;
    }

    pub fn thumb(&mut self, thumb: Option<ThumbEnum>) {
        self.thumb = thumb;
    }

    pub fn disable_notification(&mut self, disable_notification: Option<bool>) {
        self.disable_notification = disable_notification;
    }

    pub fn reply_to_message_id(&mut self, reply_to_message_id: Option<isize>) {
        self.reply_to_message_id = reply_to_message_id;
    }

    pub fn allow_sending_without_reply(&mut self, allow_sending_without_reply: Option<bool>) {
        self.allow_sending_without_reply = allow_sending_without_reply;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<ReplyMarkupEnum>) {
        self.reply_markup = reply_markup;
    }
}

impl SendMediaGroupParams {
    pub fn new(chat_id: ChatIdEnum, media: Vec<MediaEnum>) -> Self {
        Self {
            chat_id,
            media,
            disable_notification: None,
            reply_to_message_id: None,
            allow_sending_without_reply: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn media(&mut self, media: Vec<MediaEnum>) {
        self.media = media;
    }

    pub fn disable_notification(&mut self, disable_notification: Option<bool>) {
        self.disable_notification = disable_notification;
    }

    pub fn reply_to_message_id(&mut self, reply_to_message_id: Option<isize>) {
        self.reply_to_message_id = reply_to_message_id;
    }

    pub fn allow_sending_without_reply(&mut self, allow_sending_without_reply: Option<bool>) {
        self.allow_sending_without_reply = allow_sending_without_reply;
    }
}

impl SendLocationParams {
    pub fn new(chat_id: ChatIdEnum, latitude: f64, longitude: f64) -> Self {
        Self {
            chat_id,
            latitude,
            longitude,
            horizontal_accuracy: None,
            live_period: None,
            heading: None,
            proximity_alert_radius: None,
            disable_notification: None,
            reply_to_message_id: None,
            allow_sending_without_reply: None,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn latitude(&mut self, latitude: f64) {
        self.latitude = latitude;
    }

    pub fn longitude(&mut self, longitude: f64) {
        self.longitude = longitude;
    }

    pub fn horizontal_accuracy(&mut self, horizontal_accuracy: Option<f64>) {
        self.horizontal_accuracy = horizontal_accuracy;
    }

    pub fn live_period(&mut self, live_period: Option<isize>) {
        self.live_period = live_period;
    }

    pub fn heading(&mut self, heading: Option<isize>) {
        self.heading = heading;
    }

    pub fn proximity_alert_radius(&mut self, proximity_alert_radius: Option<isize>) {
        self.proximity_alert_radius = proximity_alert_radius;
    }

    pub fn disable_notification(&mut self, disable_notification: Option<bool>) {
        self.disable_notification = disable_notification;
    }

    pub fn reply_to_message_id(&mut self, reply_to_message_id: Option<isize>) {
        self.reply_to_message_id = reply_to_message_id;
    }

    pub fn allow_sending_without_reply(&mut self, allow_sending_without_reply: Option<bool>) {
        self.allow_sending_without_reply = allow_sending_without_reply;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<ReplyMarkupEnum>) {
        self.reply_markup = reply_markup;
    }
}

impl EditMessageLiveLocationParams {
    pub fn new(latitude: f64, longitude: f64) -> Self {
        Self {
            latitude,
            longitude,
            chat_id: None,
            message_id: None,
            inline_message_id: None,
            horizontal_accuracy: None,
            heading: None,
            proximity_alert_radius: None,
            reply_markup: None,
        }
    }

    pub fn latitude(&mut self, latitude: f64) {
        self.latitude = latitude;
    }

    pub fn longitude(&mut self, longitude: f64) {
        self.longitude = longitude;
    }

    pub fn chat_id(&mut self, chat_id: Option<ChatIdEnum>) {
        self.chat_id = chat_id;
    }

    pub fn message_id(&mut self, message_id: Option<isize>) {
        self.message_id = message_id;
    }

    pub fn inline_message_id(&mut self, inline_message_id: Option<String>) {
        self.inline_message_id = inline_message_id;
    }

    pub fn horizontal_accuracy(&mut self, horizontal_accuracy: Option<f64>) {
        self.horizontal_accuracy = horizontal_accuracy;
    }

    pub fn heading(&mut self, heading: Option<isize>) {
        self.heading = heading;
    }

    pub fn proximity_alert_radius(&mut self, proximity_alert_radius: Option<isize>) {
        self.proximity_alert_radius = proximity_alert_radius;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }
}

impl StopMessageLiveLocationParams {
    pub fn new() -> Self {
        Self {
            chat_id: None,
            message_id: None,
            inline_message_id: None,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: Option<ChatIdEnum>) {
        self.chat_id = chat_id;
    }

    pub fn message_id(&mut self, message_id: Option<isize>) {
        self.message_id = message_id;
    }

    pub fn inline_message_id(&mut self, inline_message_id: Option<String>) {
        self.inline_message_id = inline_message_id;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }
}

impl SendVenueParams {
    pub fn new(
        chat_id: ChatIdEnum,
        latitude: f64,
        longitude: f64,
        title: String,
        address: String,
    ) -> Self {
        Self {
            chat_id,
            latitude,
            longitude,
            title,
            address,
            foursquare_id: None,
            foursquare_type: None,
            google_place_id: None,
            google_place_type: None,
            disable_notification: None,
            reply_to_message_id: None,
            allow_sending_without_reply: None,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn latitude(&mut self, latitude: f64) {
        self.latitude = latitude;
    }

    pub fn longitude(&mut self, longitude: f64) {
        self.longitude = longitude;
    }

    pub fn title(&mut self, title: String) {
        self.title = title;
    }

    pub fn address(&mut self, address: String) {
        self.address = address;
    }

    pub fn foursquare_id(&mut self, foursquare_id: Option<String>) {
        self.foursquare_id = foursquare_id;
    }

    pub fn foursquare_type(&mut self, foursquare_type: Option<String>) {
        self.foursquare_type = foursquare_type;
    }

    pub fn google_place_id(&mut self, google_place_id: Option<String>) {
        self.google_place_id = google_place_id;
    }

    pub fn google_place_type(&mut self, google_place_type: Option<String>) {
        self.google_place_type = google_place_type;
    }

    pub fn disable_notification(&mut self, disable_notification: Option<bool>) {
        self.disable_notification = disable_notification;
    }

    pub fn reply_to_message_id(&mut self, reply_to_message_id: Option<isize>) {
        self.reply_to_message_id = reply_to_message_id;
    }

    pub fn allow_sending_without_reply(&mut self, allow_sending_without_reply: Option<bool>) {
        self.allow_sending_without_reply = allow_sending_without_reply;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<ReplyMarkupEnum>) {
        self.reply_markup = reply_markup;
    }
}

impl SendContactParams {
    pub fn new(chat_id: ChatIdEnum, phone_number: String, first_name: String) -> Self {
        Self {
            chat_id,
            phone_number,
            first_name,
            last_name: None,
            vcard: None,
            disable_notification: None,
            reply_to_message_id: None,
            allow_sending_without_reply: None,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn phone_number(&mut self, phone_number: String) {
        self.phone_number = phone_number;
    }

    pub fn first_name(&mut self, first_name: String) {
        self.first_name = first_name;
    }

    pub fn last_name(&mut self, last_name: Option<String>) {
        self.last_name = last_name;
    }

    pub fn vcard(&mut self, vcard: Option<String>) {
        self.vcard = vcard;
    }

    pub fn disable_notification(&mut self, disable_notification: Option<bool>) {
        self.disable_notification = disable_notification;
    }

    pub fn reply_to_message_id(&mut self, reply_to_message_id: Option<isize>) {
        self.reply_to_message_id = reply_to_message_id;
    }

    pub fn allow_sending_without_reply(&mut self, allow_sending_without_reply: Option<bool>) {
        self.allow_sending_without_reply = allow_sending_without_reply;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<ReplyMarkupEnum>) {
        self.reply_markup = reply_markup;
    }
}

impl SendPollParams {
    pub fn new(chat_id: ChatIdEnum, question: String, options: Vec<String>) -> Self {
        Self {
            chat_id,
            question,
            options,
            is_anonymous: None,
            type_field: None,
            allows_multiple_answers: None,
            correct_option_id: None,
            explanation: None,
            explanation_parse_mode: None,
            explanation_entities: None,
            open_period: None,
            close_date: None,
            is_closed: None,
            disable_notification: None,
            reply_to_message_id: None,
            allow_sending_without_reply: None,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn question(&mut self, question: String) {
        self.question = question;
    }

    pub fn options(&mut self, options: Vec<String>) {
        self.options = options;
    }

    pub fn is_anonymous(&mut self, is_anonymous: Option<bool>) {
        self.is_anonymous = is_anonymous;
    }

    pub fn type_field(&mut self, type_field: Option<String>) {
        self.type_field = type_field;
    }

    pub fn allows_multiple_answers(&mut self, allows_multiple_answers: Option<bool>) {
        self.allows_multiple_answers = allows_multiple_answers;
    }

    pub fn correct_option_id(&mut self, correct_option_id: Option<isize>) {
        self.correct_option_id = correct_option_id;
    }

    pub fn explanation(&mut self, explanation: Option<String>) {
        self.explanation = explanation;
    }

    pub fn explanation_parse_mode(&mut self, explanation_parse_mode: Option<String>) {
        self.explanation_parse_mode = explanation_parse_mode;
    }

    pub fn explanation_entities(&mut self, explanation_entities: Option<Vec<MessageEntity>>) {
        self.explanation_entities = explanation_entities;
    }

    pub fn open_period(&mut self, open_period: Option<isize>) {
        self.open_period = open_period;
    }

    pub fn close_date(&mut self, close_date: Option<isize>) {
        self.close_date = close_date;
    }

    pub fn is_closed(&mut self, is_closed: Option<bool>) {
        self.is_closed = is_closed;
    }

    pub fn disable_notification(&mut self, disable_notification: Option<bool>) {
        self.disable_notification = disable_notification;
    }

    pub fn reply_to_message_id(&mut self, reply_to_message_id: Option<isize>) {
        self.reply_to_message_id = reply_to_message_id;
    }

    pub fn allow_sending_without_reply(&mut self, allow_sending_without_reply: Option<bool>) {
        self.allow_sending_without_reply = allow_sending_without_reply;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<ReplyMarkupEnum>) {
        self.reply_markup = reply_markup;
    }
}

impl SendDiceParams {
    pub fn new(chat_id: ChatIdEnum) -> Self {
        Self {
            chat_id,
            emoji: None,
            disable_notification: None,
            reply_to_message_id: None,
            allow_sending_without_reply: None,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn emoji(&mut self, emoji: Option<String>) {
        self.emoji = emoji;
    }

    pub fn disable_notification(&mut self, disable_notification: Option<bool>) {
        self.disable_notification = disable_notification;
    }

    pub fn reply_to_message_id(&mut self, reply_to_message_id: Option<isize>) {
        self.reply_to_message_id = reply_to_message_id;
    }

    pub fn allow_sending_without_reply(&mut self, allow_sending_without_reply: Option<bool>) {
        self.allow_sending_without_reply = allow_sending_without_reply;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<ReplyMarkupEnum>) {
        self.reply_markup = reply_markup;
    }
}

impl SendChatActionParams {
    pub fn new(chat_id: ChatIdEnum, action: String) -> Self {
        Self { chat_id, action }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn action(&mut self, action: String) {
        self.action = action;
    }
}

impl GetUserProfilePhotosParams {
    pub fn new(user_id: isize) -> Self {
        Self {
            user_id,
            offset: None,
            limit: None,
        }
    }

    pub fn user_id(&mut self, user_id: isize) {
        self.user_id = user_id;
    }

    pub fn offset(&mut self, offset: Option<isize>) {
        self.offset = offset;
    }

    pub fn limit(&mut self, limit: Option<isize>) {
        self.limit = limit;
    }
}

impl GetFileParams {
    pub fn new(file_id: String) -> Self {
        Self { file_id }
    }

    pub fn file_id(&mut self, file_id: String) {
        self.file_id = file_id;
    }
}

impl KickChatMemberParams {
    pub fn new(chat_id: ChatIdEnum, user_id: isize) -> Self {
        Self {
            chat_id,
            user_id,
            until_date: None,
            revoke_messages: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn user_id(&mut self, user_id: isize) {
        self.user_id = user_id;
    }

    pub fn until_date(&mut self, until_date: Option<isize>) {
        self.until_date = until_date;
    }

    pub fn revoke_messages(&mut self, revoke_messages: Option<bool>) {
        self.revoke_messages = revoke_messages;
    }
}

impl UnbanChatMemberParams {
    pub fn new(chat_id: ChatIdEnum, user_id: isize) -> Self {
        Self {
            chat_id,
            user_id,
            only_if_banned: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn user_id(&mut self, user_id: isize) {
        self.user_id = user_id;
    }

    pub fn only_if_banned(&mut self, only_if_banned: Option<bool>) {
        self.only_if_banned = only_if_banned;
    }
}

impl RestrictChatMemberParams {
    pub fn new(chat_id: ChatIdEnum, user_id: isize, permissions: ChatPermissions) -> Self {
        Self {
            chat_id,
            user_id,
            permissions,
            until_date: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn user_id(&mut self, user_id: isize) {
        self.user_id = user_id;
    }

    pub fn permissions(&mut self, permissions: ChatPermissions) {
        self.permissions = permissions;
    }

    pub fn until_date(&mut self, until_date: Option<isize>) {
        self.until_date = until_date;
    }
}

impl PromoteChatMemberParams {
    pub fn new(chat_id: ChatIdEnum, user_id: isize) -> Self {
        Self {
            chat_id,
            user_id,
            is_anonymous: None,
            can_manage_chat: None,
            can_post_messages: None,
            can_edit_messages: None,
            can_delete_messages: None,
            can_manage_voice_chats: None,
            can_restrict_members: None,
            can_promote_members: None,
            can_change_info: None,
            can_invite_users: None,
            can_pin_messages: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn user_id(&mut self, user_id: isize) {
        self.user_id = user_id;
    }

    pub fn is_anonymous(&mut self, is_anonymous: Option<bool>) {
        self.is_anonymous = is_anonymous;
    }

    pub fn can_manage_chat(&mut self, can_manage_chat: Option<bool>) {
        self.can_manage_chat = can_manage_chat;
    }

    pub fn can_post_messages(&mut self, can_post_messages: Option<bool>) {
        self.can_post_messages = can_post_messages;
    }

    pub fn can_edit_messages(&mut self, can_edit_messages: Option<bool>) {
        self.can_edit_messages = can_edit_messages;
    }

    pub fn can_delete_messages(&mut self, can_delete_messages: Option<bool>) {
        self.can_delete_messages = can_delete_messages;
    }

    pub fn can_manage_voice_chats(&mut self, can_manage_voice_chats: Option<bool>) {
        self.can_manage_voice_chats = can_manage_voice_chats;
    }

    pub fn can_restrict_members(&mut self, can_restrict_members: Option<bool>) {
        self.can_restrict_members = can_restrict_members;
    }

    pub fn can_promote_members(&mut self, can_promote_members: Option<bool>) {
        self.can_promote_members = can_promote_members;
    }

    pub fn can_change_info(&mut self, can_change_info: Option<bool>) {
        self.can_change_info = can_change_info;
    }

    pub fn can_invite_users(&mut self, can_invite_users: Option<bool>) {
        self.can_invite_users = can_invite_users;
    }

    pub fn can_pin_messages(&mut self, can_pin_messages: Option<bool>) {
        self.can_pin_messages = can_pin_messages;
    }
}

impl SetChatAdministratorCustomTitleParams {
    pub fn new(chat_id: ChatIdEnum, user_id: isize, custom_title: String) -> Self {
        Self {
            chat_id,
            user_id,
            custom_title,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn user_id(&mut self, user_id: isize) {
        self.user_id = user_id;
    }

    pub fn custom_title(&mut self, custom_title: String) {
        self.custom_title = custom_title;
    }
}

impl SetChatPermissionsParams {
    pub fn new(chat_id: ChatIdEnum, permissions: ChatPermissions) -> Self {
        Self {
            chat_id,
            permissions,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn permissions(&mut self, permissions: ChatPermissions) {
        self.permissions = permissions;
    }
}

impl ExportChatInviteLinkParams {
    pub fn new(chat_id: ChatIdEnum) -> Self {
        Self { chat_id }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }
}

impl CreateChatInviteLinkParams {
    pub fn new(chat_id: ChatIdEnum) -> Self {
        Self {
            chat_id,
            expire_date: None,
            member_limit: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn expire_date(&mut self, expire_date: Option<isize>) {
        self.expire_date = expire_date;
    }

    pub fn member_limit(&mut self, member_limit: Option<isize>) {
        self.member_limit = member_limit;
    }
}

impl EditChatInviteLinkParams {
    pub fn new(chat_id: ChatIdEnum, invite_link: String) -> Self {
        Self {
            chat_id,
            invite_link,
            expire_date: None,
            member_limit: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn invite_link(&mut self, invite_link: String) {
        self.invite_link = invite_link;
    }

    pub fn expire_date(&mut self, expire_date: Option<isize>) {
        self.expire_date = expire_date;
    }

    pub fn member_limit(&mut self, member_limit: Option<isize>) {
        self.member_limit = member_limit;
    }
}

impl RevokeChatInviteLinkParams {
    pub fn new(chat_id: ChatIdEnum, invite_link: String) -> Self {
        Self {
            chat_id,
            invite_link,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn invite_link(&mut self, invite_link: String) {
        self.invite_link = invite_link;
    }
}

impl SetChatPhotoParams {
    pub fn new(chat_id: ChatIdEnum, photo: InputFile) -> Self {
        Self { chat_id, photo }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn photo(&mut self, photo: InputFile) {
        self.photo = photo;
    }
}

impl DeleteChatPhotoParams {
    pub fn new(chat_id: ChatIdEnum) -> Self {
        Self { chat_id }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }
}

impl SetChatTitleParams {
    pub fn new(chat_id: ChatIdEnum, title: String) -> Self {
        Self { chat_id, title }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn title(&mut self, title: String) {
        self.title = title;
    }
}

impl SetChatDescriptionParams {
    pub fn new(chat_id: ChatIdEnum) -> Self {
        Self {
            chat_id,
            description: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn description(&mut self, description: Option<String>) {
        self.description = description;
    }
}

impl PinChatMessageParams {
    pub fn new(chat_id: ChatIdEnum, message_id: isize) -> Self {
        Self {
            chat_id,
            message_id,
            disable_notification: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn message_id(&mut self, message_id: isize) {
        self.message_id = message_id;
    }

    pub fn disable_notification(&mut self, disable_notification: Option<bool>) {
        self.disable_notification = disable_notification;
    }
}

impl UnpinChatMessageParams {
    pub fn new(chat_id: ChatIdEnum) -> Self {
        Self {
            chat_id,
            message_id: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn message_id(&mut self, message_id: Option<isize>) {
        self.message_id = message_id;
    }
}

impl UnpinAllChatMessagesParams {
    pub fn new(chat_id: ChatIdEnum) -> Self {
        Self { chat_id }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }
}

impl LeaveChatParams {
    pub fn new(chat_id: ChatIdEnum) -> Self {
        Self { chat_id }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }
}

impl GetChatParams {
    pub fn new(chat_id: ChatIdEnum) -> Self {
        Self { chat_id }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }
}

impl GetChatAdministratorsParams {
    pub fn new(chat_id: ChatIdEnum) -> Self {
        Self { chat_id }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }
}

impl GetChatMembersCountParams {
    pub fn new(chat_id: ChatIdEnum) -> Self {
        Self { chat_id }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }
}

impl GetChatMemberParams {
    pub fn new(chat_id: ChatIdEnum, user_id: isize) -> Self {
        Self { chat_id, user_id }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn user_id(&mut self, user_id: isize) {
        self.user_id = user_id;
    }
}

impl SetChatStickerSetParams {
    pub fn new(chat_id: ChatIdEnum, sticker_set_name: String) -> Self {
        Self {
            chat_id,
            sticker_set_name,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn sticker_set_name(&mut self, sticker_set_name: String) {
        self.sticker_set_name = sticker_set_name;
    }
}

impl DeleteChatStickerSetParams {
    pub fn new(chat_id: ChatIdEnum) -> Self {
        Self { chat_id }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }
}

impl AnswerCallbackQueryParams {
    pub fn new(callback_query_id: String) -> Self {
        Self {
            callback_query_id,
            text: None,
            show_alert: None,
            url: None,
            cache_time: None,
        }
    }

    pub fn callback_query_id(&mut self, callback_query_id: String) {
        self.callback_query_id = callback_query_id;
    }

    pub fn text(&mut self, text: Option<String>) {
        self.text = text;
    }

    pub fn show_alert(&mut self, show_alert: Option<bool>) {
        self.show_alert = show_alert;
    }

    pub fn url(&mut self, url: Option<String>) {
        self.url = url;
    }

    pub fn cache_time(&mut self, cache_time: Option<isize>) {
        self.cache_time = cache_time;
    }
}

impl SetMyCommandsParams {
    pub fn new(commands: Vec<BotCommand>) -> Self {
        Self { commands }
    }

    pub fn commands(&mut self, commands: Vec<BotCommand>) {
        self.commands = commands;
    }
}

impl EditMessageTextParams {
    pub fn new(text: String) -> Self {
        Self {
            text,
            chat_id: None,
            message_id: None,
            inline_message_id: None,
            parse_mode: None,
            entities: None,
            disable_web_page_preview: None,
            reply_markup: None,
        }
    }

    pub fn text(&mut self, text: String) {
        self.text = text;
    }

    pub fn chat_id(&mut self, chat_id: Option<ChatIdEnum>) {
        self.chat_id = chat_id;
    }

    pub fn message_id(&mut self, message_id: Option<isize>) {
        self.message_id = message_id;
    }

    pub fn inline_message_id(&mut self, inline_message_id: Option<String>) {
        self.inline_message_id = inline_message_id;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn entities(&mut self, entities: Option<Vec<MessageEntity>>) {
        self.entities = entities;
    }

    pub fn disable_web_page_preview(&mut self, disable_web_page_preview: Option<bool>) {
        self.disable_web_page_preview = disable_web_page_preview;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }
}

impl EditMessageCaptionParams {
    pub fn new() -> Self {
        Self {
            chat_id: None,
            message_id: None,
            inline_message_id: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: Option<ChatIdEnum>) {
        self.chat_id = chat_id;
    }

    pub fn message_id(&mut self, message_id: Option<isize>) {
        self.message_id = message_id;
    }

    pub fn inline_message_id(&mut self, inline_message_id: Option<String>) {
        self.inline_message_id = inline_message_id;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }
}

impl EditMessageMediaParams {
    pub fn new(media: InputMedia) -> Self {
        Self {
            media,
            chat_id: None,
            message_id: None,
            inline_message_id: None,
            reply_markup: None,
        }
    }

    pub fn media(&mut self, media: InputMedia) {
        self.media = media;
    }

    pub fn chat_id(&mut self, chat_id: Option<ChatIdEnum>) {
        self.chat_id = chat_id;
    }

    pub fn message_id(&mut self, message_id: Option<isize>) {
        self.message_id = message_id;
    }

    pub fn inline_message_id(&mut self, inline_message_id: Option<String>) {
        self.inline_message_id = inline_message_id;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }
}

impl EditMessageReplyMarkupParams {
    pub fn new() -> Self {
        Self {
            chat_id: None,
            message_id: None,
            inline_message_id: None,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: Option<ChatIdEnum>) {
        self.chat_id = chat_id;
    }

    pub fn message_id(&mut self, message_id: Option<isize>) {
        self.message_id = message_id;
    }

    pub fn inline_message_id(&mut self, inline_message_id: Option<String>) {
        self.inline_message_id = inline_message_id;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }
}

impl StopPollParams {
    pub fn new(chat_id: ChatIdEnum, message_id: isize) -> Self {
        Self {
            chat_id,
            message_id,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn message_id(&mut self, message_id: isize) {
        self.message_id = message_id;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }
}

impl DeleteMessageParams {
    pub fn new(chat_id: ChatIdEnum, message_id: isize) -> Self {
        Self {
            chat_id,
            message_id,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn message_id(&mut self, message_id: isize) {
        self.message_id = message_id;
    }
}

impl SendStickerParams {
    pub fn new(chat_id: ChatIdEnum, sticker: StickerEnum) -> Self {
        Self {
            chat_id,
            sticker,
            disable_notification: None,
            reply_to_message_id: None,
            allow_sending_without_reply: None,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: ChatIdEnum) {
        self.chat_id = chat_id;
    }

    pub fn sticker(&mut self, sticker: StickerEnum) {
        self.sticker = sticker;
    }

    pub fn disable_notification(&mut self, disable_notification: Option<bool>) {
        self.disable_notification = disable_notification;
    }

    pub fn reply_to_message_id(&mut self, reply_to_message_id: Option<isize>) {
        self.reply_to_message_id = reply_to_message_id;
    }

    pub fn allow_sending_without_reply(&mut self, allow_sending_without_reply: Option<bool>) {
        self.allow_sending_without_reply = allow_sending_without_reply;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<ReplyMarkupEnum>) {
        self.reply_markup = reply_markup;
    }
}

impl GetStickerSetParams {
    pub fn new(name: String) -> Self {
        Self { name }
    }

    pub fn name(&mut self, name: String) {
        self.name = name;
    }
}

impl UploadStickerFileParams {
    pub fn new(user_id: isize, png_sticker: InputFile) -> Self {
        Self {
            user_id,
            png_sticker,
        }
    }

    pub fn user_id(&mut self, user_id: isize) {
        self.user_id = user_id;
    }

    pub fn png_sticker(&mut self, png_sticker: InputFile) {
        self.png_sticker = png_sticker;
    }
}

impl CreateNewStickerSetParams {
    pub fn new(user_id: isize, name: String, title: String, emojis: String) -> Self {
        Self {
            user_id,
            name,
            title,
            emojis,
            png_sticker: None,
            tgs_sticker: None,
            contains_masks: None,
            mask_position: None,
        }
    }

    pub fn user_id(&mut self, user_id: isize) {
        self.user_id = user_id;
    }

    pub fn name(&mut self, name: String) {
        self.name = name;
    }

    pub fn title(&mut self, title: String) {
        self.title = title;
    }

    pub fn emojis(&mut self, emojis: String) {
        self.emojis = emojis;
    }

    pub fn png_sticker(&mut self, png_sticker: Option<PngStickerEnum>) {
        self.png_sticker = png_sticker;
    }

    pub fn tgs_sticker(&mut self, tgs_sticker: Option<InputFile>) {
        self.tgs_sticker = tgs_sticker;
    }

    pub fn contains_masks(&mut self, contains_masks: Option<bool>) {
        self.contains_masks = contains_masks;
    }

    pub fn mask_position(&mut self, mask_position: Option<MaskPosition>) {
        self.mask_position = mask_position;
    }
}

impl AddStickerToSetParams {
    pub fn new(user_id: isize, name: String, emojis: String) -> Self {
        Self {
            user_id,
            name,
            emojis,
            png_sticker: None,
            tgs_sticker: None,
            mask_position: None,
        }
    }

    pub fn user_id(&mut self, user_id: isize) {
        self.user_id = user_id;
    }

    pub fn name(&mut self, name: String) {
        self.name = name;
    }

    pub fn emojis(&mut self, emojis: String) {
        self.emojis = emojis;
    }

    pub fn png_sticker(&mut self, png_sticker: Option<PngStickerEnum>) {
        self.png_sticker = png_sticker;
    }

    pub fn tgs_sticker(&mut self, tgs_sticker: Option<InputFile>) {
        self.tgs_sticker = tgs_sticker;
    }

    pub fn mask_position(&mut self, mask_position: Option<MaskPosition>) {
        self.mask_position = mask_position;
    }
}

impl SetStickerPositionInSetParams {
    pub fn new(sticker: String, position: isize) -> Self {
        Self { sticker, position }
    }

    pub fn sticker(&mut self, sticker: String) {
        self.sticker = sticker;
    }

    pub fn position(&mut self, position: isize) {
        self.position = position;
    }
}

impl DeleteStickerFromSetParams {
    pub fn new(sticker: String) -> Self {
        Self { sticker }
    }

    pub fn sticker(&mut self, sticker: String) {
        self.sticker = sticker;
    }
}

impl SetStickerSetThumbParams {
    pub fn new(name: String, user_id: isize) -> Self {
        Self {
            name,
            user_id,
            thumb: None,
        }
    }

    pub fn name(&mut self, name: String) {
        self.name = name;
    }

    pub fn user_id(&mut self, user_id: isize) {
        self.user_id = user_id;
    }

    pub fn thumb(&mut self, thumb: Option<ThumbEnum>) {
        self.thumb = thumb;
    }
}

impl AnswerInlineQueryParams {
    pub fn new(inline_query_id: String, results: Vec<InlineQueryResult>) -> Self {
        Self {
            inline_query_id,
            results,
            cache_time: None,
            is_personal: None,
            next_offset: None,
            switch_pm_text: None,
            switch_pm_parameter: None,
        }
    }

    pub fn inline_query_id(&mut self, inline_query_id: String) {
        self.inline_query_id = inline_query_id;
    }

    pub fn results(&mut self, results: Vec<InlineQueryResult>) {
        self.results = results;
    }

    pub fn cache_time(&mut self, cache_time: Option<isize>) {
        self.cache_time = cache_time;
    }

    pub fn is_personal(&mut self, is_personal: Option<bool>) {
        self.is_personal = is_personal;
    }

    pub fn next_offset(&mut self, next_offset: Option<String>) {
        self.next_offset = next_offset;
    }

    pub fn switch_pm_text(&mut self, switch_pm_text: Option<String>) {
        self.switch_pm_text = switch_pm_text;
    }

    pub fn switch_pm_parameter(&mut self, switch_pm_parameter: Option<String>) {
        self.switch_pm_parameter = switch_pm_parameter;
    }
}

impl SendInvoiceParams {
    pub fn new(
        chat_id: isize,
        title: String,
        description: String,
        payload: String,
        provider_token: String,
        start_parameter: String,
        currency: String,
        prices: Vec<LabeledPrice>,
    ) -> Self {
        Self {
            chat_id,
            title,
            description,
            payload,
            provider_token,
            start_parameter,
            currency,
            prices,
            provider_data: None,
            photo_url: None,
            photo_size: None,
            photo_width: None,
            photo_height: None,
            need_name: None,
            need_phone_number: None,
            need_email: None,
            need_shipping_address: None,
            send_phone_number_to_provider: None,
            send_email_to_provider: None,
            is_flexible: None,
            disable_notification: None,
            reply_to_message_id: None,
            allow_sending_without_reply: None,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: isize) {
        self.chat_id = chat_id;
    }

    pub fn title(&mut self, title: String) {
        self.title = title;
    }

    pub fn description(&mut self, description: String) {
        self.description = description;
    }

    pub fn payload(&mut self, payload: String) {
        self.payload = payload;
    }

    pub fn provider_token(&mut self, provider_token: String) {
        self.provider_token = provider_token;
    }

    pub fn start_parameter(&mut self, start_parameter: String) {
        self.start_parameter = start_parameter;
    }

    pub fn currency(&mut self, currency: String) {
        self.currency = currency;
    }

    pub fn prices(&mut self, prices: Vec<LabeledPrice>) {
        self.prices = prices;
    }

    pub fn provider_data(&mut self, provider_data: Option<String>) {
        self.provider_data = provider_data;
    }

    pub fn photo_url(&mut self, photo_url: Option<String>) {
        self.photo_url = photo_url;
    }

    pub fn photo_size(&mut self, photo_size: Option<isize>) {
        self.photo_size = photo_size;
    }

    pub fn photo_width(&mut self, photo_width: Option<isize>) {
        self.photo_width = photo_width;
    }

    pub fn photo_height(&mut self, photo_height: Option<isize>) {
        self.photo_height = photo_height;
    }

    pub fn need_name(&mut self, need_name: Option<bool>) {
        self.need_name = need_name;
    }

    pub fn need_phone_number(&mut self, need_phone_number: Option<bool>) {
        self.need_phone_number = need_phone_number;
    }

    pub fn need_email(&mut self, need_email: Option<bool>) {
        self.need_email = need_email;
    }

    pub fn need_shipping_address(&mut self, need_shipping_address: Option<bool>) {
        self.need_shipping_address = need_shipping_address;
    }

    pub fn send_phone_number_to_provider(&mut self, send_phone_number_to_provider: Option<bool>) {
        self.send_phone_number_to_provider = send_phone_number_to_provider;
    }

    pub fn send_email_to_provider(&mut self, send_email_to_provider: Option<bool>) {
        self.send_email_to_provider = send_email_to_provider;
    }

    pub fn is_flexible(&mut self, is_flexible: Option<bool>) {
        self.is_flexible = is_flexible;
    }

    pub fn disable_notification(&mut self, disable_notification: Option<bool>) {
        self.disable_notification = disable_notification;
    }

    pub fn reply_to_message_id(&mut self, reply_to_message_id: Option<isize>) {
        self.reply_to_message_id = reply_to_message_id;
    }

    pub fn allow_sending_without_reply(&mut self, allow_sending_without_reply: Option<bool>) {
        self.allow_sending_without_reply = allow_sending_without_reply;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }
}

impl AnswerShippingQueryParams {
    pub fn new(shipping_query_id: String, ok: bool) -> Self {
        Self {
            shipping_query_id,
            ok,
            shipping_options: None,
            error_message: None,
        }
    }

    pub fn shipping_query_id(&mut self, shipping_query_id: String) {
        self.shipping_query_id = shipping_query_id;
    }

    pub fn ok(&mut self, ok: bool) {
        self.ok = ok;
    }

    pub fn shipping_options(&mut self, shipping_options: Option<Vec<ShippingOption>>) {
        self.shipping_options = shipping_options;
    }

    pub fn error_message(&mut self, error_message: Option<String>) {
        self.error_message = error_message;
    }
}

impl AnswerPreCheckoutQueryParams {
    pub fn new(pre_checkout_query_id: String, ok: bool) -> Self {
        Self {
            pre_checkout_query_id,
            ok,
            error_message: None,
        }
    }

    pub fn pre_checkout_query_id(&mut self, pre_checkout_query_id: String) {
        self.pre_checkout_query_id = pre_checkout_query_id;
    }

    pub fn ok(&mut self, ok: bool) {
        self.ok = ok;
    }

    pub fn error_message(&mut self, error_message: Option<String>) {
        self.error_message = error_message;
    }
}

impl SetPassportDataErrorsParams {
    pub fn new(user_id: isize, errors: Vec<PassportElementError>) -> Self {
        Self { user_id, errors }
    }

    pub fn user_id(&mut self, user_id: isize) {
        self.user_id = user_id;
    }

    pub fn errors(&mut self, errors: Vec<PassportElementError>) {
        self.errors = errors;
    }
}

impl SendGameParams {
    pub fn new(chat_id: isize, game_short_name: String) -> Self {
        Self {
            chat_id,
            game_short_name,
            disable_notification: None,
            reply_to_message_id: None,
            allow_sending_without_reply: None,
            reply_markup: None,
        }
    }

    pub fn chat_id(&mut self, chat_id: isize) {
        self.chat_id = chat_id;
    }

    pub fn game_short_name(&mut self, game_short_name: String) {
        self.game_short_name = game_short_name;
    }

    pub fn disable_notification(&mut self, disable_notification: Option<bool>) {
        self.disable_notification = disable_notification;
    }

    pub fn reply_to_message_id(&mut self, reply_to_message_id: Option<isize>) {
        self.reply_to_message_id = reply_to_message_id;
    }

    pub fn allow_sending_without_reply(&mut self, allow_sending_without_reply: Option<bool>) {
        self.allow_sending_without_reply = allow_sending_without_reply;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }
}

impl SetGameScoreParams {
    pub fn new(user_id: isize, score: isize) -> Self {
        Self {
            user_id,
            score,
            force: None,
            disable_edit_message: None,
            chat_id: None,
            message_id: None,
            inline_message_id: None,
        }
    }

    pub fn user_id(&mut self, user_id: isize) {
        self.user_id = user_id;
    }

    pub fn score(&mut self, score: isize) {
        self.score = score;
    }

    pub fn force(&mut self, force: Option<bool>) {
        self.force = force;
    }

    pub fn disable_edit_message(&mut self, disable_edit_message: Option<bool>) {
        self.disable_edit_message = disable_edit_message;
    }

    pub fn chat_id(&mut self, chat_id: Option<isize>) {
        self.chat_id = chat_id;
    }

    pub fn message_id(&mut self, message_id: Option<isize>) {
        self.message_id = message_id;
    }

    pub fn inline_message_id(&mut self, inline_message_id: Option<String>) {
        self.inline_message_id = inline_message_id;
    }
}

impl GetGameHighScoresParams {
    pub fn new(user_id: isize) -> Self {
        Self {
            user_id,
            chat_id: None,
            message_id: None,
            inline_message_id: None,
        }
    }

    pub fn user_id(&mut self, user_id: isize) {
        self.user_id = user_id;
    }

    pub fn chat_id(&mut self, chat_id: Option<isize>) {
        self.chat_id = chat_id;
    }

    pub fn message_id(&mut self, message_id: Option<isize>) {
        self.message_id = message_id;
    }

    pub fn inline_message_id(&mut self, inline_message_id: Option<String>) {
        self.inline_message_id = inline_message_id;
    }
}
