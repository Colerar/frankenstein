use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum InputMessageContent {
    InputTextMessageContentVariant(InputTextMessageContent),
    InputLocationMessageContentVariant(InputLocationMessageContent),
    InputVenueMessageContentVariant(InputLocationMessageContent),
    InputContactMessageContentVariant(InputLocationMessageContent),
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct InputFile {}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct VoiceChatStarted {}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct CallbackGame {}

// All structs below are autogenerated with
// frankenstein_creator (https://github.com/ayrat555/frankenstein_creator)

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum ThumbEnum {
    InputFileVariant(InputFile),
    StringVariant(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Update {
    update_id: isize,
    message: Option<Message>,
    edited_message: Option<Message>,
    channel_post: Option<Message>,
    edited_channel_post: Option<Message>,
    inline_query: Option<InlineQuery>,
    chosen_inline_result: Option<ChosenInlineResult>,
    callback_query: Option<CallbackQuery>,
    shipping_query: Option<ShippingQuery>,
    pre_checkout_query: Option<PreCheckoutQuery>,
    poll: Option<Poll>,
    poll_answer: Option<PollAnswer>,
    my_chat_member: Option<ChatMemberUpdated>,
    chat_member: Option<ChatMemberUpdated>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WebhookInfo {
    url: String,
    has_custom_certificate: bool,
    pending_update_count: isize,
    ip_address: Option<String>,
    last_error_date: Option<isize>,
    last_error_message: Option<String>,
    max_connections: Option<isize>,
    allowed_updates: Option<Vec<String>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    id: isize,
    is_bot: bool,
    first_name: String,
    last_name: Option<String>,
    username: Option<String>,
    language_code: Option<String>,
    can_join_groups: Option<bool>,
    can_read_all_group_messages: Option<bool>,
    supports_inline_queries: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Chat {
    id: isize,
    type_field: String,
    title: Option<String>,
    username: Option<String>,
    first_name: Option<String>,
    last_name: Option<String>,
    photo: Option<ChatPhoto>,
    bio: Option<String>,
    description: Option<String>,
    invite_link: Option<String>,
    pinned_message: Option<Box<Message>>,
    permissions: Option<ChatPermissions>,
    slow_mode_delay: Option<isize>,
    message_auto_delete_time: Option<isize>,
    sticker_set_name: Option<String>,
    can_set_sticker_set: Option<bool>,
    linked_chat_id: Option<isize>,
    location: Option<ChatLocation>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Message {
    message_id: isize,
    from: Option<User>,
    sender_chat: Option<Box<Chat>>,
    date: isize,
    chat: Chat,
    forward_from: Option<User>,
    forward_from_chat: Option<Chat>,
    forward_from_message_id: Option<isize>,
    forward_signature: Option<String>,
    forward_sender_name: Option<String>,
    forward_date: Option<isize>,
    reply_to_message: Option<Box<Message>>,
    via_bot: Option<User>,
    edit_date: Option<isize>,
    media_group_id: Option<String>,
    author_signature: Option<String>,
    text: Option<String>,
    entities: Option<Vec<MessageEntity>>,
    animation: Option<Animation>,
    audio: Option<Audio>,
    document: Option<Document>,
    photo: Option<Vec<PhotoSize>>,
    sticker: Option<Sticker>,
    video: Option<Video>,
    video_note: Option<VideoNote>,
    voice: Option<Voice>,
    caption: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    contact: Option<Contact>,
    dice: Option<Dice>,
    game: Option<Game>,
    poll: Option<Poll>,
    venue: Option<Venue>,
    location: Option<Location>,
    new_chat_members: Option<Vec<User>>,
    left_chat_member: Option<User>,
    new_chat_title: Option<String>,
    new_chat_photo: Option<Vec<PhotoSize>>,
    delete_chat_photo: Option<bool>,
    group_chat_created: Option<bool>,
    supergroup_chat_created: Option<bool>,
    channel_chat_created: Option<bool>,
    message_auto_delete_timer_changed: Option<MessageAutoDeleteTimerChanged>,
    migrate_to_chat_id: Option<isize>,
    migrate_from_chat_id: Option<isize>,
    pinned_message: Option<Box<Message>>,
    invoice: Option<Invoice>,
    successful_payment: Option<SuccessfulPayment>,
    connected_website: Option<String>,
    passport_data: Option<PassportData>,
    proximity_alert_triggered: Option<ProximityAlertTriggered>,
    voice_chat_started: Option<VoiceChatStarted>,
    voice_chat_ended: Option<VoiceChatEnded>,
    voice_chat_participants_invited: Option<VoiceChatParticipantsInvited>,
    reply_markup: Option<InlineKeyboardMarkup>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageId {
    message_id: isize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageEntity {
    type_field: String,
    offset: isize,
    length: isize,
    url: Option<String>,
    user: Option<User>,
    language: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PhotoSize {
    file_id: String,
    file_unique_id: String,
    width: isize,
    height: isize,
    file_size: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Animation {
    file_id: String,
    file_unique_id: String,
    width: isize,
    height: isize,
    duration: isize,
    thumb: Option<PhotoSize>,
    file_name: Option<String>,
    mime_type: Option<String>,
    file_size: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Audio {
    file_id: String,
    file_unique_id: String,
    duration: isize,
    performer: Option<String>,
    title: Option<String>,
    file_name: Option<String>,
    mime_type: Option<String>,
    file_size: Option<isize>,
    thumb: Option<PhotoSize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Document {
    file_id: String,
    file_unique_id: String,
    thumb: Option<PhotoSize>,
    file_name: Option<String>,
    mime_type: Option<String>,
    file_size: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Video {
    file_id: String,
    file_unique_id: String,
    width: isize,
    height: isize,
    duration: isize,
    thumb: Option<PhotoSize>,
    file_name: Option<String>,
    mime_type: Option<String>,
    file_size: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VideoNote {
    file_id: String,
    file_unique_id: String,
    length: isize,
    duration: isize,
    thumb: Option<PhotoSize>,
    file_size: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Voice {
    file_id: String,
    file_unique_id: String,
    duration: isize,
    mime_type: Option<String>,
    file_size: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Contact {
    phone_number: String,
    first_name: String,
    last_name: Option<String>,
    user_id: Option<isize>,
    vcard: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Dice {
    emoji: String,
    value: isize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PollOption {
    text: String,
    voter_count: isize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PollAnswer {
    poll_id: String,
    user: User,
    option_ids: Vec<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Poll {
    id: String,
    question: String,
    options: Vec<PollOption>,
    total_voter_count: isize,
    is_closed: bool,
    is_anonymous: bool,
    type_field: String,
    allows_multiple_answers: bool,
    correct_option_id: Option<isize>,
    explanation: Option<String>,
    explanation_entities: Option<Vec<MessageEntity>>,
    open_period: Option<isize>,
    close_date: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Location {
    longitude: f64,
    latitude: f64,
    horizontal_accuracy: Option<f64>,
    live_period: Option<isize>,
    heading: Option<isize>,
    proximity_alert_radius: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Venue {
    location: Location,
    title: String,
    address: String,
    foursquare_id: Option<String>,
    foursquare_type: Option<String>,
    google_place_id: Option<String>,
    google_place_type: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProximityAlertTriggered {
    traveler: User,
    watcher: User,
    distance: isize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageAutoDeleteTimerChanged {
    message_auto_delete_time: isize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VoiceChatEnded {
    duration: isize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VoiceChatParticipantsInvited {
    users: Option<Vec<User>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserProfilePhotos {
    total_count: isize,
    photos: Vec<PhotoSize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct File {
    file_id: String,
    file_unique_id: String,
    file_size: Option<isize>,
    file_path: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReplyKeyboardMarkup {
    keyboard: Vec<KeyboardButton>,
    resize_keyboard: Option<bool>,
    one_time_keyboard: Option<bool>,
    selective: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyboardButton {
    text: String,
    request_contact: Option<bool>,
    request_location: Option<bool>,
    request_poll: Option<KeyboardButtonPollType>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyboardButtonPollType {
    type_field: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReplyKeyboardRemove {
    remove_keyboard: bool,
    selective: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineKeyboardMarkup {
    inline_keyboard: Vec<InlineKeyboardButton>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineKeyboardButton {
    text: String,
    url: Option<String>,
    login_url: Option<LoginUrl>,
    callback_data: Option<String>,
    switch_inline_query: Option<String>,
    switch_inline_query_current_chat: Option<String>,
    callback_game: Option<CallbackGame>,
    pay: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LoginUrl {
    url: String,
    forward_text: Option<String>,
    bot_username: Option<String>,
    request_write_access: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallbackQuery {
    id: String,
    from: User,
    message: Option<Message>,
    inline_message_id: Option<String>,
    chat_instance: String,
    data: Option<String>,
    game_short_name: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ForceReply {
    force_reply: bool,
    selective: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatPhoto {
    small_file_id: String,
    small_file_unique_id: String,
    big_file_id: String,
    big_file_unique_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatInviteLink {
    invite_link: String,
    creator: User,
    is_primary: bool,
    is_revoked: bool,
    expire_date: Option<isize>,
    member_limit: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMember {
    user: User,
    status: String,
    custom_title: Option<String>,
    is_anonymous: Option<bool>,
    can_be_edited: Option<bool>,
    can_manage_chat: Option<bool>,
    can_post_messages: Option<bool>,
    can_edit_messages: Option<bool>,
    can_delete_messages: Option<bool>,
    can_manage_voice_chats: Option<bool>,
    can_restrict_members: Option<bool>,
    can_promote_members: Option<bool>,
    can_change_info: Option<bool>,
    can_invite_users: Option<bool>,
    can_pin_messages: Option<bool>,
    is_member: Option<bool>,
    can_send_messages: Option<bool>,
    can_send_media_messages: Option<bool>,
    can_send_polls: Option<bool>,
    can_send_other_messages: Option<bool>,
    can_add_web_page_previews: Option<bool>,
    until_date: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMemberUpdated {
    chat: Chat,
    from: User,
    date: isize,
    old_chat_member: ChatMember,
    new_chat_member: ChatMember,
    invite_link: Option<ChatInviteLink>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatPermissions {
    can_send_messages: Option<bool>,
    can_send_media_messages: Option<bool>,
    can_send_polls: Option<bool>,
    can_send_other_messages: Option<bool>,
    can_add_web_page_previews: Option<bool>,
    can_change_info: Option<bool>,
    can_invite_users: Option<bool>,
    can_pin_messages: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatLocation {
    location: Location,
    address: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BotCommand {
    command: String,
    description: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResponseParameters {
    migrate_to_chat_id: Option<isize>,
    retry_after: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMediaPhoto {
    type_field: String,
    media: String,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMediaVideo {
    type_field: String,
    media: String,
    thumb: Option<ThumbEnum>,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    width: Option<isize>,
    height: Option<isize>,
    duration: Option<isize>,
    supports_streaming: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMediaAnimation {
    type_field: String,
    media: String,
    thumb: Option<ThumbEnum>,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    width: Option<isize>,
    height: Option<isize>,
    duration: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMediaAudio {
    type_field: String,
    media: String,
    thumb: Option<ThumbEnum>,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    duration: Option<isize>,
    performer: Option<String>,
    title: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMediaDocument {
    type_field: String,
    media: String,
    thumb: Option<ThumbEnum>,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    disable_content_type_detection: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Sticker {
    file_id: String,
    file_unique_id: String,
    width: isize,
    height: isize,
    is_animated: bool,
    thumb: Option<PhotoSize>,
    emoji: Option<String>,
    set_name: Option<String>,
    mask_position: Option<MaskPosition>,
    file_size: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StickerSet {
    name: String,
    title: String,
    is_animated: bool,
    contains_masks: bool,
    stickers: Vec<Sticker>,
    thumb: Option<PhotoSize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MaskPosition {
    point: String,
    x_shift: f64,
    y_shift: f64,
    scale: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQuery {
    id: String,
    from: User,
    location: Option<Location>,
    query: String,
    offset: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultArticle {
    type_field: String,
    id: String,
    title: String,
    input_message_content: InputMessageContent,
    reply_markup: Option<InlineKeyboardMarkup>,
    url: Option<String>,
    hide_url: Option<bool>,
    description: Option<String>,
    thumb_url: Option<String>,
    thumb_width: Option<isize>,
    thumb_height: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultPhoto {
    type_field: String,
    id: String,
    photo_url: String,
    thumb_url: String,
    photo_width: Option<isize>,
    photo_height: Option<isize>,
    title: Option<String>,
    description: Option<String>,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    reply_markup: Option<InlineKeyboardMarkup>,
    input_message_content: Option<InputMessageContent>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultGif {
    type_field: String,
    id: String,
    gif_url: String,
    gif_width: Option<isize>,
    gif_height: Option<isize>,
    gif_duration: Option<isize>,
    thumb_url: String,
    thumb_mime_type: Option<String>,
    title: Option<String>,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    reply_markup: Option<InlineKeyboardMarkup>,
    input_message_content: Option<InputMessageContent>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultMpeg4Gif {
    type_field: String,
    id: String,
    mpeg4_url: String,
    mpeg4_width: Option<isize>,
    mpeg4_height: Option<isize>,
    mpeg4_duration: Option<isize>,
    thumb_url: String,
    thumb_mime_type: Option<String>,
    title: Option<String>,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    reply_markup: Option<InlineKeyboardMarkup>,
    input_message_content: Option<InputMessageContent>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultVideo {
    type_field: String,
    id: String,
    video_url: String,
    mime_type: String,
    thumb_url: String,
    title: String,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    video_width: Option<isize>,
    video_height: Option<isize>,
    video_duration: Option<isize>,
    description: Option<String>,
    reply_markup: Option<InlineKeyboardMarkup>,
    input_message_content: Option<InputMessageContent>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultAudio {
    type_field: String,
    id: String,
    audio_url: String,
    title: String,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    performer: Option<String>,
    audio_duration: Option<isize>,
    reply_markup: Option<InlineKeyboardMarkup>,
    input_message_content: Option<InputMessageContent>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultVoice {
    type_field: String,
    id: String,
    voice_url: String,
    title: String,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    voice_duration: Option<isize>,
    reply_markup: Option<InlineKeyboardMarkup>,
    input_message_content: Option<InputMessageContent>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultDocument {
    type_field: String,
    id: String,
    title: String,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    document_url: String,
    mime_type: String,
    description: Option<String>,
    reply_markup: Option<InlineKeyboardMarkup>,
    input_message_content: Option<InputMessageContent>,
    thumb_url: Option<String>,
    thumb_width: Option<isize>,
    thumb_height: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultLocation {
    type_field: String,
    id: String,
    latitude: f64,
    longitude: f64,
    title: String,
    horizontal_accuracy: Option<f64>,
    live_period: Option<isize>,
    heading: Option<isize>,
    proximity_alert_radius: Option<isize>,
    reply_markup: Option<InlineKeyboardMarkup>,
    input_message_content: Option<InputMessageContent>,
    thumb_url: Option<String>,
    thumb_width: Option<isize>,
    thumb_height: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultVenue {
    type_field: String,
    id: String,
    latitude: f64,
    longitude: f64,
    title: String,
    address: String,
    foursquare_id: Option<String>,
    foursquare_type: Option<String>,
    google_place_id: Option<String>,
    google_place_type: Option<String>,
    reply_markup: Option<InlineKeyboardMarkup>,
    input_message_content: Option<InputMessageContent>,
    thumb_url: Option<String>,
    thumb_width: Option<isize>,
    thumb_height: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultContact {
    type_field: String,
    id: String,
    phone_number: String,
    first_name: String,
    last_name: Option<String>,
    vcard: Option<String>,
    reply_markup: Option<InlineKeyboardMarkup>,
    input_message_content: Option<InputMessageContent>,
    thumb_url: Option<String>,
    thumb_width: Option<isize>,
    thumb_height: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultGame {
    type_field: String,
    id: String,
    game_short_name: String,
    reply_markup: Option<InlineKeyboardMarkup>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultCachedPhoto {
    type_field: String,
    id: String,
    photo_file_id: String,
    title: Option<String>,
    description: Option<String>,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    reply_markup: Option<InlineKeyboardMarkup>,
    input_message_content: Option<InputMessageContent>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultCachedGif {
    type_field: String,
    id: String,
    gif_file_id: String,
    title: Option<String>,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    reply_markup: Option<InlineKeyboardMarkup>,
    input_message_content: Option<InputMessageContent>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultCachedMpeg4Gif {
    type_field: String,
    id: String,
    mpeg4_file_id: String,
    title: Option<String>,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    reply_markup: Option<InlineKeyboardMarkup>,
    input_message_content: Option<InputMessageContent>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultCachedSticker {
    type_field: String,
    id: String,
    sticker_file_id: String,
    reply_markup: Option<InlineKeyboardMarkup>,
    input_message_content: Option<InputMessageContent>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultCachedDocument {
    type_field: String,
    id: String,
    title: String,
    document_file_id: String,
    description: Option<String>,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    reply_markup: Option<InlineKeyboardMarkup>,
    input_message_content: Option<InputMessageContent>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultCachedVideo {
    type_field: String,
    id: String,
    video_file_id: String,
    title: String,
    description: Option<String>,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    reply_markup: Option<InlineKeyboardMarkup>,
    input_message_content: Option<InputMessageContent>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultCachedVoice {
    type_field: String,
    id: String,
    voice_file_id: String,
    title: String,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    reply_markup: Option<InlineKeyboardMarkup>,
    input_message_content: Option<InputMessageContent>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultCachedAudio {
    type_field: String,
    id: String,
    audio_file_id: String,
    caption: Option<String>,
    parse_mode: Option<String>,
    caption_entities: Option<Vec<MessageEntity>>,
    reply_markup: Option<InlineKeyboardMarkup>,
    input_message_content: Option<InputMessageContent>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputTextMessageContent {
    message_text: String,
    parse_mode: Option<String>,
    entities: Option<Vec<MessageEntity>>,
    disable_web_page_preview: Option<bool>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputLocationMessageContent {
    latitude: f64,
    longitude: f64,
    horizontal_accuracy: Option<f64>,
    live_period: Option<isize>,
    heading: Option<isize>,
    proximity_alert_radius: Option<isize>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputVenueMessageContent {
    latitude: f64,
    longitude: f64,
    title: String,
    address: String,
    foursquare_id: Option<String>,
    foursquare_type: Option<String>,
    google_place_id: Option<String>,
    google_place_type: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputContactMessageContent {
    phone_number: String,
    first_name: String,
    last_name: Option<String>,
    vcard: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChosenInlineResult {
    result_id: String,
    from: User,
    location: Option<Location>,
    inline_message_id: Option<String>,
    query: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LabeledPrice {
    label: String,
    amount: isize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Invoice {
    title: String,
    description: String,
    start_parameter: String,
    currency: String,
    total_amount: isize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShippingAddress {
    country_code: String,
    state: String,
    city: String,
    street_line1: String,
    street_line2: String,
    post_code: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderInfo {
    name: Option<String>,
    phone_number: Option<String>,
    email: Option<String>,
    shipping_address: Option<ShippingAddress>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShippingOption {
    id: String,
    title: String,
    prices: Vec<LabeledPrice>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SuccessfulPayment {
    currency: String,
    total_amount: isize,
    invoice_payload: String,
    shipping_option_id: Option<String>,
    order_info: Option<OrderInfo>,
    telegram_payment_charge_id: String,
    provider_payment_charge_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShippingQuery {
    id: String,
    from: User,
    invoice_payload: String,
    shipping_address: ShippingAddress,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PreCheckoutQuery {
    id: String,
    from: User,
    currency: String,
    total_amount: isize,
    invoice_payload: String,
    shipping_option_id: Option<String>,
    order_info: Option<OrderInfo>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportData {
    data: Vec<EncryptedPassportElement>,
    credentials: EncryptedCredentials,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportFile {
    file_id: String,
    file_unique_id: String,
    file_size: isize,
    file_date: isize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EncryptedPassportElement {
    type_field: String,
    data: Option<String>,
    phone_number: Option<String>,
    email: Option<String>,
    files: Option<Vec<PassportFile>>,
    front_side: Option<PassportFile>,
    reverse_side: Option<PassportFile>,
    selfie: Option<PassportFile>,
    translation: Option<Vec<PassportFile>>,
    hash: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EncryptedCredentials {
    data: String,
    hash: String,
    secret: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorDataField {
    source: String,
    type_field: String,
    field_name: String,
    data_hash: String,
    message: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorFrontSide {
    source: String,
    type_field: String,
    file_hash: String,
    message: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorReverseSide {
    source: String,
    type_field: String,
    file_hash: String,
    message: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSelfie {
    source: String,
    type_field: String,
    file_hash: String,
    message: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorFile {
    source: String,
    type_field: String,
    file_hash: String,
    message: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorFiles {
    source: String,
    type_field: String,
    file_hashes: Vec<String>,
    message: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorTranslationFile {
    source: String,
    type_field: String,
    file_hash: String,
    message: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorTranslationFiles {
    source: String,
    type_field: String,
    file_hashes: Vec<String>,
    message: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorUnspecified {
    source: String,
    type_field: String,
    element_hash: String,
    message: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Game {
    title: String,
    description: String,
    photo: Vec<PhotoSize>,
    text: Option<String>,
    text_entities: Option<Vec<MessageEntity>>,
    animation: Option<Animation>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GameHighScore {
    position: isize,
    user: User,
    score: isize,
}

impl Update {
    pub fn new(update_id: isize) -> Self {
        Self {
            update_id,
            message: None,
            edited_message: None,
            channel_post: None,
            edited_channel_post: None,
            inline_query: None,
            chosen_inline_result: None,
            callback_query: None,
            shipping_query: None,
            pre_checkout_query: None,
            poll: None,
            poll_answer: None,
            my_chat_member: None,
            chat_member: None,
        }
    }

    pub fn update_id(&mut self, update_id: isize) {
        self.update_id = update_id;
    }

    pub fn message(&mut self, message: Option<Message>) {
        self.message = message;
    }

    pub fn edited_message(&mut self, edited_message: Option<Message>) {
        self.edited_message = edited_message;
    }

    pub fn channel_post(&mut self, channel_post: Option<Message>) {
        self.channel_post = channel_post;
    }

    pub fn edited_channel_post(&mut self, edited_channel_post: Option<Message>) {
        self.edited_channel_post = edited_channel_post;
    }

    pub fn inline_query(&mut self, inline_query: Option<InlineQuery>) {
        self.inline_query = inline_query;
    }

    pub fn chosen_inline_result(&mut self, chosen_inline_result: Option<ChosenInlineResult>) {
        self.chosen_inline_result = chosen_inline_result;
    }

    pub fn callback_query(&mut self, callback_query: Option<CallbackQuery>) {
        self.callback_query = callback_query;
    }

    pub fn shipping_query(&mut self, shipping_query: Option<ShippingQuery>) {
        self.shipping_query = shipping_query;
    }

    pub fn pre_checkout_query(&mut self, pre_checkout_query: Option<PreCheckoutQuery>) {
        self.pre_checkout_query = pre_checkout_query;
    }

    pub fn poll(&mut self, poll: Option<Poll>) {
        self.poll = poll;
    }

    pub fn poll_answer(&mut self, poll_answer: Option<PollAnswer>) {
        self.poll_answer = poll_answer;
    }

    pub fn my_chat_member(&mut self, my_chat_member: Option<ChatMemberUpdated>) {
        self.my_chat_member = my_chat_member;
    }

    pub fn chat_member(&mut self, chat_member: Option<ChatMemberUpdated>) {
        self.chat_member = chat_member;
    }
}

impl WebhookInfo {
    pub fn new(url: String, has_custom_certificate: bool, pending_update_count: isize) -> Self {
        Self {
            url,
            has_custom_certificate,
            pending_update_count,
            ip_address: None,
            last_error_date: None,
            last_error_message: None,
            max_connections: None,
            allowed_updates: None,
        }
    }

    pub fn url(&mut self, url: String) {
        self.url = url;
    }

    pub fn has_custom_certificate(&mut self, has_custom_certificate: bool) {
        self.has_custom_certificate = has_custom_certificate;
    }

    pub fn pending_update_count(&mut self, pending_update_count: isize) {
        self.pending_update_count = pending_update_count;
    }

    pub fn ip_address(&mut self, ip_address: Option<String>) {
        self.ip_address = ip_address;
    }

    pub fn last_error_date(&mut self, last_error_date: Option<isize>) {
        self.last_error_date = last_error_date;
    }

    pub fn last_error_message(&mut self, last_error_message: Option<String>) {
        self.last_error_message = last_error_message;
    }

    pub fn max_connections(&mut self, max_connections: Option<isize>) {
        self.max_connections = max_connections;
    }

    pub fn allowed_updates(&mut self, allowed_updates: Option<Vec<String>>) {
        self.allowed_updates = allowed_updates;
    }
}

impl User {
    pub fn new(id: isize, is_bot: bool, first_name: String) -> Self {
        Self {
            id,
            is_bot,
            first_name,
            last_name: None,
            username: None,
            language_code: None,
            can_join_groups: None,
            can_read_all_group_messages: None,
            supports_inline_queries: None,
        }
    }

    pub fn id(&mut self, id: isize) {
        self.id = id;
    }

    pub fn is_bot(&mut self, is_bot: bool) {
        self.is_bot = is_bot;
    }

    pub fn first_name(&mut self, first_name: String) {
        self.first_name = first_name;
    }

    pub fn last_name(&mut self, last_name: Option<String>) {
        self.last_name = last_name;
    }

    pub fn username(&mut self, username: Option<String>) {
        self.username = username;
    }

    pub fn language_code(&mut self, language_code: Option<String>) {
        self.language_code = language_code;
    }

    pub fn can_join_groups(&mut self, can_join_groups: Option<bool>) {
        self.can_join_groups = can_join_groups;
    }

    pub fn can_read_all_group_messages(&mut self, can_read_all_group_messages: Option<bool>) {
        self.can_read_all_group_messages = can_read_all_group_messages;
    }

    pub fn supports_inline_queries(&mut self, supports_inline_queries: Option<bool>) {
        self.supports_inline_queries = supports_inline_queries;
    }
}

impl Chat {
    pub fn new(id: isize, type_field: String) -> Self {
        Self {
            id,
            type_field,
            title: None,
            username: None,
            first_name: None,
            last_name: None,
            photo: None,
            bio: None,
            description: None,
            invite_link: None,
            pinned_message: None,
            permissions: None,
            slow_mode_delay: None,
            message_auto_delete_time: None,
            sticker_set_name: None,
            can_set_sticker_set: None,
            linked_chat_id: None,
            location: None,
        }
    }

    pub fn id(&mut self, id: isize) {
        self.id = id;
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn title(&mut self, title: Option<String>) {
        self.title = title;
    }

    pub fn username(&mut self, username: Option<String>) {
        self.username = username;
    }

    pub fn first_name(&mut self, first_name: Option<String>) {
        self.first_name = first_name;
    }

    pub fn last_name(&mut self, last_name: Option<String>) {
        self.last_name = last_name;
    }

    pub fn photo(&mut self, photo: Option<ChatPhoto>) {
        self.photo = photo;
    }

    pub fn bio(&mut self, bio: Option<String>) {
        self.bio = bio;
    }

    pub fn description(&mut self, description: Option<String>) {
        self.description = description;
    }

    pub fn invite_link(&mut self, invite_link: Option<String>) {
        self.invite_link = invite_link;
    }

    pub fn pinned_message(&mut self, pinned_message: Option<Box<Message>>) {
        self.pinned_message = pinned_message;
    }

    pub fn permissions(&mut self, permissions: Option<ChatPermissions>) {
        self.permissions = permissions;
    }

    pub fn slow_mode_delay(&mut self, slow_mode_delay: Option<isize>) {
        self.slow_mode_delay = slow_mode_delay;
    }

    pub fn message_auto_delete_time(&mut self, message_auto_delete_time: Option<isize>) {
        self.message_auto_delete_time = message_auto_delete_time;
    }

    pub fn sticker_set_name(&mut self, sticker_set_name: Option<String>) {
        self.sticker_set_name = sticker_set_name;
    }

    pub fn can_set_sticker_set(&mut self, can_set_sticker_set: Option<bool>) {
        self.can_set_sticker_set = can_set_sticker_set;
    }

    pub fn linked_chat_id(&mut self, linked_chat_id: Option<isize>) {
        self.linked_chat_id = linked_chat_id;
    }

    pub fn location(&mut self, location: Option<ChatLocation>) {
        self.location = location;
    }
}

impl Message {
    pub fn new(message_id: isize, date: isize, chat: Chat) -> Self {
        Self {
            message_id,
            date,
            chat,
            from: None,
            sender_chat: None,
            forward_from: None,
            forward_from_chat: None,
            forward_from_message_id: None,
            forward_signature: None,
            forward_sender_name: None,
            forward_date: None,
            reply_to_message: None,
            via_bot: None,
            edit_date: None,
            media_group_id: None,
            author_signature: None,
            text: None,
            entities: None,
            animation: None,
            audio: None,
            document: None,
            photo: None,
            sticker: None,
            video: None,
            video_note: None,
            voice: None,
            caption: None,
            caption_entities: None,
            contact: None,
            dice: None,
            game: None,
            poll: None,
            venue: None,
            location: None,
            new_chat_members: None,
            left_chat_member: None,
            new_chat_title: None,
            new_chat_photo: None,
            delete_chat_photo: None,
            group_chat_created: None,
            supergroup_chat_created: None,
            channel_chat_created: None,
            message_auto_delete_timer_changed: None,
            migrate_to_chat_id: None,
            migrate_from_chat_id: None,
            pinned_message: None,
            invoice: None,
            successful_payment: None,
            connected_website: None,
            passport_data: None,
            proximity_alert_triggered: None,
            voice_chat_started: None,
            voice_chat_ended: None,
            voice_chat_participants_invited: None,
            reply_markup: None,
        }
    }

    pub fn message_id(&mut self, message_id: isize) {
        self.message_id = message_id;
    }

    pub fn date(&mut self, date: isize) {
        self.date = date;
    }

    pub fn chat(&mut self, chat: Chat) {
        self.chat = chat;
    }

    pub fn from(&mut self, from: Option<User>) {
        self.from = from;
    }

    pub fn sender_chat(&mut self, sender_chat: Option<Box<Chat>>) {
        self.sender_chat = sender_chat;
    }

    pub fn forward_from(&mut self, forward_from: Option<User>) {
        self.forward_from = forward_from;
    }

    pub fn forward_from_chat(&mut self, forward_from_chat: Option<Chat>) {
        self.forward_from_chat = forward_from_chat;
    }

    pub fn forward_from_message_id(&mut self, forward_from_message_id: Option<isize>) {
        self.forward_from_message_id = forward_from_message_id;
    }

    pub fn forward_signature(&mut self, forward_signature: Option<String>) {
        self.forward_signature = forward_signature;
    }

    pub fn forward_sender_name(&mut self, forward_sender_name: Option<String>) {
        self.forward_sender_name = forward_sender_name;
    }

    pub fn forward_date(&mut self, forward_date: Option<isize>) {
        self.forward_date = forward_date;
    }

    pub fn reply_to_message(&mut self, reply_to_message: Option<Box<Message>>) {
        self.reply_to_message = reply_to_message;
    }

    pub fn via_bot(&mut self, via_bot: Option<User>) {
        self.via_bot = via_bot;
    }

    pub fn edit_date(&mut self, edit_date: Option<isize>) {
        self.edit_date = edit_date;
    }

    pub fn media_group_id(&mut self, media_group_id: Option<String>) {
        self.media_group_id = media_group_id;
    }

    pub fn author_signature(&mut self, author_signature: Option<String>) {
        self.author_signature = author_signature;
    }

    pub fn text(&mut self, text: Option<String>) {
        self.text = text;
    }

    pub fn entities(&mut self, entities: Option<Vec<MessageEntity>>) {
        self.entities = entities;
    }

    pub fn animation(&mut self, animation: Option<Animation>) {
        self.animation = animation;
    }

    pub fn audio(&mut self, audio: Option<Audio>) {
        self.audio = audio;
    }

    pub fn document(&mut self, document: Option<Document>) {
        self.document = document;
    }

    pub fn photo(&mut self, photo: Option<Vec<PhotoSize>>) {
        self.photo = photo;
    }

    pub fn sticker(&mut self, sticker: Option<Sticker>) {
        self.sticker = sticker;
    }

    pub fn video(&mut self, video: Option<Video>) {
        self.video = video;
    }

    pub fn video_note(&mut self, video_note: Option<VideoNote>) {
        self.video_note = video_note;
    }

    pub fn voice(&mut self, voice: Option<Voice>) {
        self.voice = voice;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn contact(&mut self, contact: Option<Contact>) {
        self.contact = contact;
    }

    pub fn dice(&mut self, dice: Option<Dice>) {
        self.dice = dice;
    }

    pub fn game(&mut self, game: Option<Game>) {
        self.game = game;
    }

    pub fn poll(&mut self, poll: Option<Poll>) {
        self.poll = poll;
    }

    pub fn venue(&mut self, venue: Option<Venue>) {
        self.venue = venue;
    }

    pub fn location(&mut self, location: Option<Location>) {
        self.location = location;
    }

    pub fn new_chat_members(&mut self, new_chat_members: Option<Vec<User>>) {
        self.new_chat_members = new_chat_members;
    }

    pub fn left_chat_member(&mut self, left_chat_member: Option<User>) {
        self.left_chat_member = left_chat_member;
    }

    pub fn new_chat_title(&mut self, new_chat_title: Option<String>) {
        self.new_chat_title = new_chat_title;
    }

    pub fn new_chat_photo(&mut self, new_chat_photo: Option<Vec<PhotoSize>>) {
        self.new_chat_photo = new_chat_photo;
    }

    pub fn delete_chat_photo(&mut self, delete_chat_photo: Option<bool>) {
        self.delete_chat_photo = delete_chat_photo;
    }

    pub fn group_chat_created(&mut self, group_chat_created: Option<bool>) {
        self.group_chat_created = group_chat_created;
    }

    pub fn supergroup_chat_created(&mut self, supergroup_chat_created: Option<bool>) {
        self.supergroup_chat_created = supergroup_chat_created;
    }

    pub fn channel_chat_created(&mut self, channel_chat_created: Option<bool>) {
        self.channel_chat_created = channel_chat_created;
    }

    pub fn message_auto_delete_timer_changed(
        &mut self,
        message_auto_delete_timer_changed: Option<MessageAutoDeleteTimerChanged>,
    ) {
        self.message_auto_delete_timer_changed = message_auto_delete_timer_changed;
    }

    pub fn migrate_to_chat_id(&mut self, migrate_to_chat_id: Option<isize>) {
        self.migrate_to_chat_id = migrate_to_chat_id;
    }

    pub fn migrate_from_chat_id(&mut self, migrate_from_chat_id: Option<isize>) {
        self.migrate_from_chat_id = migrate_from_chat_id;
    }

    pub fn pinned_message(&mut self, pinned_message: Option<Box<Message>>) {
        self.pinned_message = pinned_message;
    }

    pub fn invoice(&mut self, invoice: Option<Invoice>) {
        self.invoice = invoice;
    }

    pub fn successful_payment(&mut self, successful_payment: Option<SuccessfulPayment>) {
        self.successful_payment = successful_payment;
    }

    pub fn connected_website(&mut self, connected_website: Option<String>) {
        self.connected_website = connected_website;
    }

    pub fn passport_data(&mut self, passport_data: Option<PassportData>) {
        self.passport_data = passport_data;
    }

    pub fn proximity_alert_triggered(
        &mut self,
        proximity_alert_triggered: Option<ProximityAlertTriggered>,
    ) {
        self.proximity_alert_triggered = proximity_alert_triggered;
    }

    pub fn voice_chat_started(&mut self, voice_chat_started: Option<VoiceChatStarted>) {
        self.voice_chat_started = voice_chat_started;
    }

    pub fn voice_chat_ended(&mut self, voice_chat_ended: Option<VoiceChatEnded>) {
        self.voice_chat_ended = voice_chat_ended;
    }

    pub fn voice_chat_participants_invited(
        &mut self,
        voice_chat_participants_invited: Option<VoiceChatParticipantsInvited>,
    ) {
        self.voice_chat_participants_invited = voice_chat_participants_invited;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }
}

impl MessageId {
    pub fn new(message_id: isize) -> Self {
        Self { message_id }
    }

    pub fn message_id(&mut self, message_id: isize) {
        self.message_id = message_id;
    }
}

impl MessageEntity {
    pub fn new(type_field: String, offset: isize, length: isize) -> Self {
        Self {
            type_field,
            offset,
            length,
            url: None,
            user: None,
            language: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn offset(&mut self, offset: isize) {
        self.offset = offset;
    }

    pub fn length(&mut self, length: isize) {
        self.length = length;
    }

    pub fn url(&mut self, url: Option<String>) {
        self.url = url;
    }

    pub fn user(&mut self, user: Option<User>) {
        self.user = user;
    }

    pub fn language(&mut self, language: Option<String>) {
        self.language = language;
    }
}

impl PhotoSize {
    pub fn new(file_id: String, file_unique_id: String, width: isize, height: isize) -> Self {
        Self {
            file_id,
            file_unique_id,
            width,
            height,
            file_size: None,
        }
    }

    pub fn file_id(&mut self, file_id: String) {
        self.file_id = file_id;
    }

    pub fn file_unique_id(&mut self, file_unique_id: String) {
        self.file_unique_id = file_unique_id;
    }

    pub fn width(&mut self, width: isize) {
        self.width = width;
    }

    pub fn height(&mut self, height: isize) {
        self.height = height;
    }

    pub fn file_size(&mut self, file_size: Option<isize>) {
        self.file_size = file_size;
    }
}

impl Animation {
    pub fn new(
        file_id: String,
        file_unique_id: String,
        width: isize,
        height: isize,
        duration: isize,
    ) -> Self {
        Self {
            file_id,
            file_unique_id,
            width,
            height,
            duration,
            thumb: None,
            file_name: None,
            mime_type: None,
            file_size: None,
        }
    }

    pub fn file_id(&mut self, file_id: String) {
        self.file_id = file_id;
    }

    pub fn file_unique_id(&mut self, file_unique_id: String) {
        self.file_unique_id = file_unique_id;
    }

    pub fn width(&mut self, width: isize) {
        self.width = width;
    }

    pub fn height(&mut self, height: isize) {
        self.height = height;
    }

    pub fn duration(&mut self, duration: isize) {
        self.duration = duration;
    }

    pub fn thumb(&mut self, thumb: Option<PhotoSize>) {
        self.thumb = thumb;
    }

    pub fn file_name(&mut self, file_name: Option<String>) {
        self.file_name = file_name;
    }

    pub fn mime_type(&mut self, mime_type: Option<String>) {
        self.mime_type = mime_type;
    }

    pub fn file_size(&mut self, file_size: Option<isize>) {
        self.file_size = file_size;
    }
}

impl Audio {
    pub fn new(file_id: String, file_unique_id: String, duration: isize) -> Self {
        Self {
            file_id,
            file_unique_id,
            duration,
            performer: None,
            title: None,
            file_name: None,
            mime_type: None,
            file_size: None,
            thumb: None,
        }
    }

    pub fn file_id(&mut self, file_id: String) {
        self.file_id = file_id;
    }

    pub fn file_unique_id(&mut self, file_unique_id: String) {
        self.file_unique_id = file_unique_id;
    }

    pub fn duration(&mut self, duration: isize) {
        self.duration = duration;
    }

    pub fn performer(&mut self, performer: Option<String>) {
        self.performer = performer;
    }

    pub fn title(&mut self, title: Option<String>) {
        self.title = title;
    }

    pub fn file_name(&mut self, file_name: Option<String>) {
        self.file_name = file_name;
    }

    pub fn mime_type(&mut self, mime_type: Option<String>) {
        self.mime_type = mime_type;
    }

    pub fn file_size(&mut self, file_size: Option<isize>) {
        self.file_size = file_size;
    }

    pub fn thumb(&mut self, thumb: Option<PhotoSize>) {
        self.thumb = thumb;
    }
}

impl Document {
    pub fn new(file_id: String, file_unique_id: String) -> Self {
        Self {
            file_id,
            file_unique_id,
            thumb: None,
            file_name: None,
            mime_type: None,
            file_size: None,
        }
    }

    pub fn file_id(&mut self, file_id: String) {
        self.file_id = file_id;
    }

    pub fn file_unique_id(&mut self, file_unique_id: String) {
        self.file_unique_id = file_unique_id;
    }

    pub fn thumb(&mut self, thumb: Option<PhotoSize>) {
        self.thumb = thumb;
    }

    pub fn file_name(&mut self, file_name: Option<String>) {
        self.file_name = file_name;
    }

    pub fn mime_type(&mut self, mime_type: Option<String>) {
        self.mime_type = mime_type;
    }

    pub fn file_size(&mut self, file_size: Option<isize>) {
        self.file_size = file_size;
    }
}

impl Video {
    pub fn new(
        file_id: String,
        file_unique_id: String,
        width: isize,
        height: isize,
        duration: isize,
    ) -> Self {
        Self {
            file_id,
            file_unique_id,
            width,
            height,
            duration,
            thumb: None,
            file_name: None,
            mime_type: None,
            file_size: None,
        }
    }

    pub fn file_id(&mut self, file_id: String) {
        self.file_id = file_id;
    }

    pub fn file_unique_id(&mut self, file_unique_id: String) {
        self.file_unique_id = file_unique_id;
    }

    pub fn width(&mut self, width: isize) {
        self.width = width;
    }

    pub fn height(&mut self, height: isize) {
        self.height = height;
    }

    pub fn duration(&mut self, duration: isize) {
        self.duration = duration;
    }

    pub fn thumb(&mut self, thumb: Option<PhotoSize>) {
        self.thumb = thumb;
    }

    pub fn file_name(&mut self, file_name: Option<String>) {
        self.file_name = file_name;
    }

    pub fn mime_type(&mut self, mime_type: Option<String>) {
        self.mime_type = mime_type;
    }

    pub fn file_size(&mut self, file_size: Option<isize>) {
        self.file_size = file_size;
    }
}

impl VideoNote {
    pub fn new(file_id: String, file_unique_id: String, length: isize, duration: isize) -> Self {
        Self {
            file_id,
            file_unique_id,
            length,
            duration,
            thumb: None,
            file_size: None,
        }
    }

    pub fn file_id(&mut self, file_id: String) {
        self.file_id = file_id;
    }

    pub fn file_unique_id(&mut self, file_unique_id: String) {
        self.file_unique_id = file_unique_id;
    }

    pub fn length(&mut self, length: isize) {
        self.length = length;
    }

    pub fn duration(&mut self, duration: isize) {
        self.duration = duration;
    }

    pub fn thumb(&mut self, thumb: Option<PhotoSize>) {
        self.thumb = thumb;
    }

    pub fn file_size(&mut self, file_size: Option<isize>) {
        self.file_size = file_size;
    }
}

impl Voice {
    pub fn new(file_id: String, file_unique_id: String, duration: isize) -> Self {
        Self {
            file_id,
            file_unique_id,
            duration,
            mime_type: None,
            file_size: None,
        }
    }

    pub fn file_id(&mut self, file_id: String) {
        self.file_id = file_id;
    }

    pub fn file_unique_id(&mut self, file_unique_id: String) {
        self.file_unique_id = file_unique_id;
    }

    pub fn duration(&mut self, duration: isize) {
        self.duration = duration;
    }

    pub fn mime_type(&mut self, mime_type: Option<String>) {
        self.mime_type = mime_type;
    }

    pub fn file_size(&mut self, file_size: Option<isize>) {
        self.file_size = file_size;
    }
}

impl Contact {
    pub fn new(phone_number: String, first_name: String) -> Self {
        Self {
            phone_number,
            first_name,
            last_name: None,
            user_id: None,
            vcard: None,
        }
    }

    pub fn phone_number(&mut self, phone_number: String) {
        self.phone_number = phone_number;
    }

    pub fn first_name(&mut self, first_name: String) {
        self.first_name = first_name;
    }

    pub fn last_name(&mut self, last_name: Option<String>) {
        self.last_name = last_name;
    }

    pub fn user_id(&mut self, user_id: Option<isize>) {
        self.user_id = user_id;
    }

    pub fn vcard(&mut self, vcard: Option<String>) {
        self.vcard = vcard;
    }
}

impl Dice {
    pub fn new(emoji: String, value: isize) -> Self {
        Self { emoji, value }
    }

    pub fn emoji(&mut self, emoji: String) {
        self.emoji = emoji;
    }

    pub fn value(&mut self, value: isize) {
        self.value = value;
    }
}

impl PollOption {
    pub fn new(text: String, voter_count: isize) -> Self {
        Self { text, voter_count }
    }

    pub fn text(&mut self, text: String) {
        self.text = text;
    }

    pub fn voter_count(&mut self, voter_count: isize) {
        self.voter_count = voter_count;
    }
}

impl PollAnswer {
    pub fn new(poll_id: String, user: User, option_ids: Vec<isize>) -> Self {
        Self {
            poll_id,
            user,
            option_ids,
        }
    }

    pub fn poll_id(&mut self, poll_id: String) {
        self.poll_id = poll_id;
    }

    pub fn user(&mut self, user: User) {
        self.user = user;
    }

    pub fn option_ids(&mut self, option_ids: Vec<isize>) {
        self.option_ids = option_ids;
    }
}

impl Poll {
    pub fn new(
        id: String,
        question: String,
        options: Vec<PollOption>,
        total_voter_count: isize,
        is_closed: bool,
        is_anonymous: bool,
        type_field: String,
        allows_multiple_answers: bool,
    ) -> Self {
        Self {
            id,
            question,
            options,
            total_voter_count,
            is_closed,
            is_anonymous,
            type_field,
            allows_multiple_answers,
            correct_option_id: None,
            explanation: None,
            explanation_entities: None,
            open_period: None,
            close_date: None,
        }
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn question(&mut self, question: String) {
        self.question = question;
    }

    pub fn options(&mut self, options: Vec<PollOption>) {
        self.options = options;
    }

    pub fn total_voter_count(&mut self, total_voter_count: isize) {
        self.total_voter_count = total_voter_count;
    }

    pub fn is_closed(&mut self, is_closed: bool) {
        self.is_closed = is_closed;
    }

    pub fn is_anonymous(&mut self, is_anonymous: bool) {
        self.is_anonymous = is_anonymous;
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn allows_multiple_answers(&mut self, allows_multiple_answers: bool) {
        self.allows_multiple_answers = allows_multiple_answers;
    }

    pub fn correct_option_id(&mut self, correct_option_id: Option<isize>) {
        self.correct_option_id = correct_option_id;
    }

    pub fn explanation(&mut self, explanation: Option<String>) {
        self.explanation = explanation;
    }

    pub fn explanation_entities(&mut self, explanation_entities: Option<Vec<MessageEntity>>) {
        self.explanation_entities = explanation_entities;
    }

    pub fn open_period(&mut self, open_period: Option<isize>) {
        self.open_period = open_period;
    }

    pub fn close_date(&mut self, close_date: Option<isize>) {
        self.close_date = close_date;
    }
}

impl Location {
    pub fn new(longitude: f64, latitude: f64) -> Self {
        Self {
            longitude,
            latitude,
            horizontal_accuracy: None,
            live_period: None,
            heading: None,
            proximity_alert_radius: None,
        }
    }

    pub fn longitude(&mut self, longitude: f64) {
        self.longitude = longitude;
    }

    pub fn latitude(&mut self, latitude: f64) {
        self.latitude = latitude;
    }

    pub fn horizontal_accuracy(&mut self, horizontal_accuracy: Option<f64>) {
        self.horizontal_accuracy = horizontal_accuracy;
    }

    pub fn live_period(&mut self, live_period: Option<isize>) {
        self.live_period = live_period;
    }

    pub fn heading(&mut self, heading: Option<isize>) {
        self.heading = heading;
    }

    pub fn proximity_alert_radius(&mut self, proximity_alert_radius: Option<isize>) {
        self.proximity_alert_radius = proximity_alert_radius;
    }
}

impl Venue {
    pub fn new(location: Location, title: String, address: String) -> Self {
        Self {
            location,
            title,
            address,
            foursquare_id: None,
            foursquare_type: None,
            google_place_id: None,
            google_place_type: None,
        }
    }

    pub fn location(&mut self, location: Location) {
        self.location = location;
    }

    pub fn title(&mut self, title: String) {
        self.title = title;
    }

    pub fn address(&mut self, address: String) {
        self.address = address;
    }

    pub fn foursquare_id(&mut self, foursquare_id: Option<String>) {
        self.foursquare_id = foursquare_id;
    }

    pub fn foursquare_type(&mut self, foursquare_type: Option<String>) {
        self.foursquare_type = foursquare_type;
    }

    pub fn google_place_id(&mut self, google_place_id: Option<String>) {
        self.google_place_id = google_place_id;
    }

    pub fn google_place_type(&mut self, google_place_type: Option<String>) {
        self.google_place_type = google_place_type;
    }
}

impl ProximityAlertTriggered {
    pub fn new(traveler: User, watcher: User, distance: isize) -> Self {
        Self {
            traveler,
            watcher,
            distance,
        }
    }

    pub fn traveler(&mut self, traveler: User) {
        self.traveler = traveler;
    }

    pub fn watcher(&mut self, watcher: User) {
        self.watcher = watcher;
    }

    pub fn distance(&mut self, distance: isize) {
        self.distance = distance;
    }
}

impl MessageAutoDeleteTimerChanged {
    pub fn new(message_auto_delete_time: isize) -> Self {
        Self {
            message_auto_delete_time,
        }
    }

    pub fn message_auto_delete_time(&mut self, message_auto_delete_time: isize) {
        self.message_auto_delete_time = message_auto_delete_time;
    }
}

impl VoiceChatEnded {
    pub fn new(duration: isize) -> Self {
        Self { duration }
    }

    pub fn duration(&mut self, duration: isize) {
        self.duration = duration;
    }
}

impl VoiceChatParticipantsInvited {
    pub fn new() -> Self {
        Self { users: None }
    }

    pub fn users(&mut self, users: Option<Vec<User>>) {
        self.users = users;
    }
}

impl UserProfilePhotos {
    pub fn new(total_count: isize, photos: Vec<PhotoSize>) -> Self {
        Self {
            total_count,
            photos,
        }
    }

    pub fn total_count(&mut self, total_count: isize) {
        self.total_count = total_count;
    }

    pub fn photos(&mut self, photos: Vec<PhotoSize>) {
        self.photos = photos;
    }
}

impl File {
    pub fn new(file_id: String, file_unique_id: String) -> Self {
        Self {
            file_id,
            file_unique_id,
            file_size: None,
            file_path: None,
        }
    }

    pub fn file_id(&mut self, file_id: String) {
        self.file_id = file_id;
    }

    pub fn file_unique_id(&mut self, file_unique_id: String) {
        self.file_unique_id = file_unique_id;
    }

    pub fn file_size(&mut self, file_size: Option<isize>) {
        self.file_size = file_size;
    }

    pub fn file_path(&mut self, file_path: Option<String>) {
        self.file_path = file_path;
    }
}

impl ReplyKeyboardMarkup {
    pub fn new(keyboard: Vec<KeyboardButton>) -> Self {
        Self {
            keyboard,
            resize_keyboard: None,
            one_time_keyboard: None,
            selective: None,
        }
    }

    pub fn keyboard(&mut self, keyboard: Vec<KeyboardButton>) {
        self.keyboard = keyboard;
    }

    pub fn resize_keyboard(&mut self, resize_keyboard: Option<bool>) {
        self.resize_keyboard = resize_keyboard;
    }

    pub fn one_time_keyboard(&mut self, one_time_keyboard: Option<bool>) {
        self.one_time_keyboard = one_time_keyboard;
    }

    pub fn selective(&mut self, selective: Option<bool>) {
        self.selective = selective;
    }
}

impl KeyboardButton {
    pub fn new(text: String) -> Self {
        Self {
            text,
            request_contact: None,
            request_location: None,
            request_poll: None,
        }
    }

    pub fn text(&mut self, text: String) {
        self.text = text;
    }

    pub fn request_contact(&mut self, request_contact: Option<bool>) {
        self.request_contact = request_contact;
    }

    pub fn request_location(&mut self, request_location: Option<bool>) {
        self.request_location = request_location;
    }

    pub fn request_poll(&mut self, request_poll: Option<KeyboardButtonPollType>) {
        self.request_poll = request_poll;
    }
}

impl KeyboardButtonPollType {
    pub fn new() -> Self {
        Self { type_field: None }
    }

    pub fn type_field(&mut self, type_field: Option<String>) {
        self.type_field = type_field;
    }
}

impl ReplyKeyboardRemove {
    pub fn new(remove_keyboard: bool) -> Self {
        Self {
            remove_keyboard,
            selective: None,
        }
    }

    pub fn remove_keyboard(&mut self, remove_keyboard: bool) {
        self.remove_keyboard = remove_keyboard;
    }

    pub fn selective(&mut self, selective: Option<bool>) {
        self.selective = selective;
    }
}

impl InlineKeyboardMarkup {
    pub fn new(inline_keyboard: Vec<InlineKeyboardButton>) -> Self {
        Self { inline_keyboard }
    }

    pub fn inline_keyboard(&mut self, inline_keyboard: Vec<InlineKeyboardButton>) {
        self.inline_keyboard = inline_keyboard;
    }
}

impl InlineKeyboardButton {
    pub fn new(text: String) -> Self {
        Self {
            text,
            url: None,
            login_url: None,
            callback_data: None,
            switch_inline_query: None,
            switch_inline_query_current_chat: None,
            callback_game: None,
            pay: None,
        }
    }

    pub fn text(&mut self, text: String) {
        self.text = text;
    }

    pub fn url(&mut self, url: Option<String>) {
        self.url = url;
    }

    pub fn login_url(&mut self, login_url: Option<LoginUrl>) {
        self.login_url = login_url;
    }

    pub fn callback_data(&mut self, callback_data: Option<String>) {
        self.callback_data = callback_data;
    }

    pub fn switch_inline_query(&mut self, switch_inline_query: Option<String>) {
        self.switch_inline_query = switch_inline_query;
    }

    pub fn switch_inline_query_current_chat(
        &mut self,
        switch_inline_query_current_chat: Option<String>,
    ) {
        self.switch_inline_query_current_chat = switch_inline_query_current_chat;
    }

    pub fn callback_game(&mut self, callback_game: Option<CallbackGame>) {
        self.callback_game = callback_game;
    }

    pub fn pay(&mut self, pay: Option<bool>) {
        self.pay = pay;
    }
}

impl LoginUrl {
    pub fn new(url: String) -> Self {
        Self {
            url,
            forward_text: None,
            bot_username: None,
            request_write_access: None,
        }
    }

    pub fn url(&mut self, url: String) {
        self.url = url;
    }

    pub fn forward_text(&mut self, forward_text: Option<String>) {
        self.forward_text = forward_text;
    }

    pub fn bot_username(&mut self, bot_username: Option<String>) {
        self.bot_username = bot_username;
    }

    pub fn request_write_access(&mut self, request_write_access: Option<bool>) {
        self.request_write_access = request_write_access;
    }
}

impl CallbackQuery {
    pub fn new(id: String, from: User, chat_instance: String) -> Self {
        Self {
            id,
            from,
            chat_instance,
            message: None,
            inline_message_id: None,
            data: None,
            game_short_name: None,
        }
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn from(&mut self, from: User) {
        self.from = from;
    }

    pub fn chat_instance(&mut self, chat_instance: String) {
        self.chat_instance = chat_instance;
    }

    pub fn message(&mut self, message: Option<Message>) {
        self.message = message;
    }

    pub fn inline_message_id(&mut self, inline_message_id: Option<String>) {
        self.inline_message_id = inline_message_id;
    }

    pub fn data(&mut self, data: Option<String>) {
        self.data = data;
    }

    pub fn game_short_name(&mut self, game_short_name: Option<String>) {
        self.game_short_name = game_short_name;
    }
}

impl ForceReply {
    pub fn new(force_reply: bool) -> Self {
        Self {
            force_reply,
            selective: None,
        }
    }

    pub fn force_reply(&mut self, force_reply: bool) {
        self.force_reply = force_reply;
    }

    pub fn selective(&mut self, selective: Option<bool>) {
        self.selective = selective;
    }
}

impl ChatPhoto {
    pub fn new(
        small_file_id: String,
        small_file_unique_id: String,
        big_file_id: String,
        big_file_unique_id: String,
    ) -> Self {
        Self {
            small_file_id,
            small_file_unique_id,
            big_file_id,
            big_file_unique_id,
        }
    }

    pub fn small_file_id(&mut self, small_file_id: String) {
        self.small_file_id = small_file_id;
    }

    pub fn small_file_unique_id(&mut self, small_file_unique_id: String) {
        self.small_file_unique_id = small_file_unique_id;
    }

    pub fn big_file_id(&mut self, big_file_id: String) {
        self.big_file_id = big_file_id;
    }

    pub fn big_file_unique_id(&mut self, big_file_unique_id: String) {
        self.big_file_unique_id = big_file_unique_id;
    }
}

impl ChatInviteLink {
    pub fn new(invite_link: String, creator: User, is_primary: bool, is_revoked: bool) -> Self {
        Self {
            invite_link,
            creator,
            is_primary,
            is_revoked,
            expire_date: None,
            member_limit: None,
        }
    }

    pub fn invite_link(&mut self, invite_link: String) {
        self.invite_link = invite_link;
    }

    pub fn creator(&mut self, creator: User) {
        self.creator = creator;
    }

    pub fn is_primary(&mut self, is_primary: bool) {
        self.is_primary = is_primary;
    }

    pub fn is_revoked(&mut self, is_revoked: bool) {
        self.is_revoked = is_revoked;
    }

    pub fn expire_date(&mut self, expire_date: Option<isize>) {
        self.expire_date = expire_date;
    }

    pub fn member_limit(&mut self, member_limit: Option<isize>) {
        self.member_limit = member_limit;
    }
}

impl ChatMember {
    pub fn new(user: User, status: String) -> Self {
        Self {
            user,
            status,
            custom_title: None,
            is_anonymous: None,
            can_be_edited: None,
            can_manage_chat: None,
            can_post_messages: None,
            can_edit_messages: None,
            can_delete_messages: None,
            can_manage_voice_chats: None,
            can_restrict_members: None,
            can_promote_members: None,
            can_change_info: None,
            can_invite_users: None,
            can_pin_messages: None,
            is_member: None,
            can_send_messages: None,
            can_send_media_messages: None,
            can_send_polls: None,
            can_send_other_messages: None,
            can_add_web_page_previews: None,
            until_date: None,
        }
    }

    pub fn user(&mut self, user: User) {
        self.user = user;
    }

    pub fn status(&mut self, status: String) {
        self.status = status;
    }

    pub fn custom_title(&mut self, custom_title: Option<String>) {
        self.custom_title = custom_title;
    }

    pub fn is_anonymous(&mut self, is_anonymous: Option<bool>) {
        self.is_anonymous = is_anonymous;
    }

    pub fn can_be_edited(&mut self, can_be_edited: Option<bool>) {
        self.can_be_edited = can_be_edited;
    }

    pub fn can_manage_chat(&mut self, can_manage_chat: Option<bool>) {
        self.can_manage_chat = can_manage_chat;
    }

    pub fn can_post_messages(&mut self, can_post_messages: Option<bool>) {
        self.can_post_messages = can_post_messages;
    }

    pub fn can_edit_messages(&mut self, can_edit_messages: Option<bool>) {
        self.can_edit_messages = can_edit_messages;
    }

    pub fn can_delete_messages(&mut self, can_delete_messages: Option<bool>) {
        self.can_delete_messages = can_delete_messages;
    }

    pub fn can_manage_voice_chats(&mut self, can_manage_voice_chats: Option<bool>) {
        self.can_manage_voice_chats = can_manage_voice_chats;
    }

    pub fn can_restrict_members(&mut self, can_restrict_members: Option<bool>) {
        self.can_restrict_members = can_restrict_members;
    }

    pub fn can_promote_members(&mut self, can_promote_members: Option<bool>) {
        self.can_promote_members = can_promote_members;
    }

    pub fn can_change_info(&mut self, can_change_info: Option<bool>) {
        self.can_change_info = can_change_info;
    }

    pub fn can_invite_users(&mut self, can_invite_users: Option<bool>) {
        self.can_invite_users = can_invite_users;
    }

    pub fn can_pin_messages(&mut self, can_pin_messages: Option<bool>) {
        self.can_pin_messages = can_pin_messages;
    }

    pub fn is_member(&mut self, is_member: Option<bool>) {
        self.is_member = is_member;
    }

    pub fn can_send_messages(&mut self, can_send_messages: Option<bool>) {
        self.can_send_messages = can_send_messages;
    }

    pub fn can_send_media_messages(&mut self, can_send_media_messages: Option<bool>) {
        self.can_send_media_messages = can_send_media_messages;
    }

    pub fn can_send_polls(&mut self, can_send_polls: Option<bool>) {
        self.can_send_polls = can_send_polls;
    }

    pub fn can_send_other_messages(&mut self, can_send_other_messages: Option<bool>) {
        self.can_send_other_messages = can_send_other_messages;
    }

    pub fn can_add_web_page_previews(&mut self, can_add_web_page_previews: Option<bool>) {
        self.can_add_web_page_previews = can_add_web_page_previews;
    }

    pub fn until_date(&mut self, until_date: Option<isize>) {
        self.until_date = until_date;
    }
}

impl ChatMemberUpdated {
    pub fn new(
        chat: Chat,
        from: User,
        date: isize,
        old_chat_member: ChatMember,
        new_chat_member: ChatMember,
    ) -> Self {
        Self {
            chat,
            from,
            date,
            old_chat_member,
            new_chat_member,
            invite_link: None,
        }
    }

    pub fn chat(&mut self, chat: Chat) {
        self.chat = chat;
    }

    pub fn from(&mut self, from: User) {
        self.from = from;
    }

    pub fn date(&mut self, date: isize) {
        self.date = date;
    }

    pub fn old_chat_member(&mut self, old_chat_member: ChatMember) {
        self.old_chat_member = old_chat_member;
    }

    pub fn new_chat_member(&mut self, new_chat_member: ChatMember) {
        self.new_chat_member = new_chat_member;
    }

    pub fn invite_link(&mut self, invite_link: Option<ChatInviteLink>) {
        self.invite_link = invite_link;
    }
}

impl ChatPermissions {
    pub fn new() -> Self {
        Self {
            can_send_messages: None,
            can_send_media_messages: None,
            can_send_polls: None,
            can_send_other_messages: None,
            can_add_web_page_previews: None,
            can_change_info: None,
            can_invite_users: None,
            can_pin_messages: None,
        }
    }

    pub fn can_send_messages(&mut self, can_send_messages: Option<bool>) {
        self.can_send_messages = can_send_messages;
    }

    pub fn can_send_media_messages(&mut self, can_send_media_messages: Option<bool>) {
        self.can_send_media_messages = can_send_media_messages;
    }

    pub fn can_send_polls(&mut self, can_send_polls: Option<bool>) {
        self.can_send_polls = can_send_polls;
    }

    pub fn can_send_other_messages(&mut self, can_send_other_messages: Option<bool>) {
        self.can_send_other_messages = can_send_other_messages;
    }

    pub fn can_add_web_page_previews(&mut self, can_add_web_page_previews: Option<bool>) {
        self.can_add_web_page_previews = can_add_web_page_previews;
    }

    pub fn can_change_info(&mut self, can_change_info: Option<bool>) {
        self.can_change_info = can_change_info;
    }

    pub fn can_invite_users(&mut self, can_invite_users: Option<bool>) {
        self.can_invite_users = can_invite_users;
    }

    pub fn can_pin_messages(&mut self, can_pin_messages: Option<bool>) {
        self.can_pin_messages = can_pin_messages;
    }
}

impl ChatLocation {
    pub fn new(location: Location, address: String) -> Self {
        Self { location, address }
    }

    pub fn location(&mut self, location: Location) {
        self.location = location;
    }

    pub fn address(&mut self, address: String) {
        self.address = address;
    }
}

impl BotCommand {
    pub fn new(command: String, description: String) -> Self {
        Self {
            command,
            description,
        }
    }

    pub fn command(&mut self, command: String) {
        self.command = command;
    }

    pub fn description(&mut self, description: String) {
        self.description = description;
    }
}

impl ResponseParameters {
    pub fn new() -> Self {
        Self {
            migrate_to_chat_id: None,
            retry_after: None,
        }
    }

    pub fn migrate_to_chat_id(&mut self, migrate_to_chat_id: Option<isize>) {
        self.migrate_to_chat_id = migrate_to_chat_id;
    }

    pub fn retry_after(&mut self, retry_after: Option<isize>) {
        self.retry_after = retry_after;
    }
}

impl InputMediaPhoto {
    pub fn new(type_field: String, media: String) -> Self {
        Self {
            type_field,
            media,
            caption: None,
            parse_mode: None,
            caption_entities: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn media(&mut self, media: String) {
        self.media = media;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }
}

impl InputMediaVideo {
    pub fn new(type_field: String, media: String) -> Self {
        Self {
            type_field,
            media,
            thumb: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            width: None,
            height: None,
            duration: None,
            supports_streaming: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn media(&mut self, media: String) {
        self.media = media;
    }

    pub fn thumb(&mut self, thumb: Option<ThumbEnum>) {
        self.thumb = thumb;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn width(&mut self, width: Option<isize>) {
        self.width = width;
    }

    pub fn height(&mut self, height: Option<isize>) {
        self.height = height;
    }

    pub fn duration(&mut self, duration: Option<isize>) {
        self.duration = duration;
    }

    pub fn supports_streaming(&mut self, supports_streaming: Option<bool>) {
        self.supports_streaming = supports_streaming;
    }
}

impl InputMediaAnimation {
    pub fn new(type_field: String, media: String) -> Self {
        Self {
            type_field,
            media,
            thumb: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            width: None,
            height: None,
            duration: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn media(&mut self, media: String) {
        self.media = media;
    }

    pub fn thumb(&mut self, thumb: Option<ThumbEnum>) {
        self.thumb = thumb;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn width(&mut self, width: Option<isize>) {
        self.width = width;
    }

    pub fn height(&mut self, height: Option<isize>) {
        self.height = height;
    }

    pub fn duration(&mut self, duration: Option<isize>) {
        self.duration = duration;
    }
}

impl InputMediaAudio {
    pub fn new(type_field: String, media: String) -> Self {
        Self {
            type_field,
            media,
            thumb: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            duration: None,
            performer: None,
            title: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn media(&mut self, media: String) {
        self.media = media;
    }

    pub fn thumb(&mut self, thumb: Option<ThumbEnum>) {
        self.thumb = thumb;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn duration(&mut self, duration: Option<isize>) {
        self.duration = duration;
    }

    pub fn performer(&mut self, performer: Option<String>) {
        self.performer = performer;
    }

    pub fn title(&mut self, title: Option<String>) {
        self.title = title;
    }
}

impl InputMediaDocument {
    pub fn new(type_field: String, media: String) -> Self {
        Self {
            type_field,
            media,
            thumb: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            disable_content_type_detection: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn media(&mut self, media: String) {
        self.media = media;
    }

    pub fn thumb(&mut self, thumb: Option<ThumbEnum>) {
        self.thumb = thumb;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn disable_content_type_detection(&mut self, disable_content_type_detection: Option<bool>) {
        self.disable_content_type_detection = disable_content_type_detection;
    }
}

impl Sticker {
    pub fn new(
        file_id: String,
        file_unique_id: String,
        width: isize,
        height: isize,
        is_animated: bool,
    ) -> Self {
        Self {
            file_id,
            file_unique_id,
            width,
            height,
            is_animated,
            thumb: None,
            emoji: None,
            set_name: None,
            mask_position: None,
            file_size: None,
        }
    }

    pub fn file_id(&mut self, file_id: String) {
        self.file_id = file_id;
    }

    pub fn file_unique_id(&mut self, file_unique_id: String) {
        self.file_unique_id = file_unique_id;
    }

    pub fn width(&mut self, width: isize) {
        self.width = width;
    }

    pub fn height(&mut self, height: isize) {
        self.height = height;
    }

    pub fn is_animated(&mut self, is_animated: bool) {
        self.is_animated = is_animated;
    }

    pub fn thumb(&mut self, thumb: Option<PhotoSize>) {
        self.thumb = thumb;
    }

    pub fn emoji(&mut self, emoji: Option<String>) {
        self.emoji = emoji;
    }

    pub fn set_name(&mut self, set_name: Option<String>) {
        self.set_name = set_name;
    }

    pub fn mask_position(&mut self, mask_position: Option<MaskPosition>) {
        self.mask_position = mask_position;
    }

    pub fn file_size(&mut self, file_size: Option<isize>) {
        self.file_size = file_size;
    }
}

impl StickerSet {
    pub fn new(
        name: String,
        title: String,
        is_animated: bool,
        contains_masks: bool,
        stickers: Vec<Sticker>,
    ) -> Self {
        Self {
            name,
            title,
            is_animated,
            contains_masks,
            stickers,
            thumb: None,
        }
    }

    pub fn name(&mut self, name: String) {
        self.name = name;
    }

    pub fn title(&mut self, title: String) {
        self.title = title;
    }

    pub fn is_animated(&mut self, is_animated: bool) {
        self.is_animated = is_animated;
    }

    pub fn contains_masks(&mut self, contains_masks: bool) {
        self.contains_masks = contains_masks;
    }

    pub fn stickers(&mut self, stickers: Vec<Sticker>) {
        self.stickers = stickers;
    }

    pub fn thumb(&mut self, thumb: Option<PhotoSize>) {
        self.thumb = thumb;
    }
}

impl MaskPosition {
    pub fn new(point: String, x_shift: f64, y_shift: f64, scale: f64) -> Self {
        Self {
            point,
            x_shift,
            y_shift,
            scale,
        }
    }

    pub fn point(&mut self, point: String) {
        self.point = point;
    }

    pub fn x_shift(&mut self, x_shift: f64) {
        self.x_shift = x_shift;
    }

    pub fn y_shift(&mut self, y_shift: f64) {
        self.y_shift = y_shift;
    }

    pub fn scale(&mut self, scale: f64) {
        self.scale = scale;
    }
}

impl InlineQuery {
    pub fn new(id: String, from: User, query: String, offset: String) -> Self {
        Self {
            id,
            from,
            query,
            offset,
            location: None,
        }
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn from(&mut self, from: User) {
        self.from = from;
    }

    pub fn query(&mut self, query: String) {
        self.query = query;
    }

    pub fn offset(&mut self, offset: String) {
        self.offset = offset;
    }

    pub fn location(&mut self, location: Option<Location>) {
        self.location = location;
    }
}

impl InlineQueryResultArticle {
    pub fn new(
        type_field: String,
        id: String,
        title: String,
        input_message_content: InputMessageContent,
    ) -> Self {
        Self {
            type_field,
            id,
            title,
            input_message_content,
            reply_markup: None,
            url: None,
            hide_url: None,
            description: None,
            thumb_url: None,
            thumb_width: None,
            thumb_height: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn title(&mut self, title: String) {
        self.title = title;
    }

    pub fn input_message_content(&mut self, input_message_content: InputMessageContent) {
        self.input_message_content = input_message_content;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }

    pub fn url(&mut self, url: Option<String>) {
        self.url = url;
    }

    pub fn hide_url(&mut self, hide_url: Option<bool>) {
        self.hide_url = hide_url;
    }

    pub fn description(&mut self, description: Option<String>) {
        self.description = description;
    }

    pub fn thumb_url(&mut self, thumb_url: Option<String>) {
        self.thumb_url = thumb_url;
    }

    pub fn thumb_width(&mut self, thumb_width: Option<isize>) {
        self.thumb_width = thumb_width;
    }

    pub fn thumb_height(&mut self, thumb_height: Option<isize>) {
        self.thumb_height = thumb_height;
    }
}

impl InlineQueryResultPhoto {
    pub fn new(type_field: String, id: String, photo_url: String, thumb_url: String) -> Self {
        Self {
            type_field,
            id,
            photo_url,
            thumb_url,
            photo_width: None,
            photo_height: None,
            title: None,
            description: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn photo_url(&mut self, photo_url: String) {
        self.photo_url = photo_url;
    }

    pub fn thumb_url(&mut self, thumb_url: String) {
        self.thumb_url = thumb_url;
    }

    pub fn photo_width(&mut self, photo_width: Option<isize>) {
        self.photo_width = photo_width;
    }

    pub fn photo_height(&mut self, photo_height: Option<isize>) {
        self.photo_height = photo_height;
    }

    pub fn title(&mut self, title: Option<String>) {
        self.title = title;
    }

    pub fn description(&mut self, description: Option<String>) {
        self.description = description;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }

    pub fn input_message_content(&mut self, input_message_content: Option<InputMessageContent>) {
        self.input_message_content = input_message_content;
    }
}

impl InlineQueryResultGif {
    pub fn new(type_field: String, id: String, gif_url: String, thumb_url: String) -> Self {
        Self {
            type_field,
            id,
            gif_url,
            thumb_url,
            gif_width: None,
            gif_height: None,
            gif_duration: None,
            thumb_mime_type: None,
            title: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn gif_url(&mut self, gif_url: String) {
        self.gif_url = gif_url;
    }

    pub fn thumb_url(&mut self, thumb_url: String) {
        self.thumb_url = thumb_url;
    }

    pub fn gif_width(&mut self, gif_width: Option<isize>) {
        self.gif_width = gif_width;
    }

    pub fn gif_height(&mut self, gif_height: Option<isize>) {
        self.gif_height = gif_height;
    }

    pub fn gif_duration(&mut self, gif_duration: Option<isize>) {
        self.gif_duration = gif_duration;
    }

    pub fn thumb_mime_type(&mut self, thumb_mime_type: Option<String>) {
        self.thumb_mime_type = thumb_mime_type;
    }

    pub fn title(&mut self, title: Option<String>) {
        self.title = title;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }

    pub fn input_message_content(&mut self, input_message_content: Option<InputMessageContent>) {
        self.input_message_content = input_message_content;
    }
}

impl InlineQueryResultMpeg4Gif {
    pub fn new(type_field: String, id: String, mpeg4_url: String, thumb_url: String) -> Self {
        Self {
            type_field,
            id,
            mpeg4_url,
            thumb_url,
            mpeg4_width: None,
            mpeg4_height: None,
            mpeg4_duration: None,
            thumb_mime_type: None,
            title: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn mpeg4_url(&mut self, mpeg4_url: String) {
        self.mpeg4_url = mpeg4_url;
    }

    pub fn thumb_url(&mut self, thumb_url: String) {
        self.thumb_url = thumb_url;
    }

    pub fn mpeg4_width(&mut self, mpeg4_width: Option<isize>) {
        self.mpeg4_width = mpeg4_width;
    }

    pub fn mpeg4_height(&mut self, mpeg4_height: Option<isize>) {
        self.mpeg4_height = mpeg4_height;
    }

    pub fn mpeg4_duration(&mut self, mpeg4_duration: Option<isize>) {
        self.mpeg4_duration = mpeg4_duration;
    }

    pub fn thumb_mime_type(&mut self, thumb_mime_type: Option<String>) {
        self.thumb_mime_type = thumb_mime_type;
    }

    pub fn title(&mut self, title: Option<String>) {
        self.title = title;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }

    pub fn input_message_content(&mut self, input_message_content: Option<InputMessageContent>) {
        self.input_message_content = input_message_content;
    }
}

impl InlineQueryResultVideo {
    pub fn new(
        type_field: String,
        id: String,
        video_url: String,
        mime_type: String,
        thumb_url: String,
        title: String,
    ) -> Self {
        Self {
            type_field,
            id,
            video_url,
            mime_type,
            thumb_url,
            title,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            video_width: None,
            video_height: None,
            video_duration: None,
            description: None,
            reply_markup: None,
            input_message_content: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn video_url(&mut self, video_url: String) {
        self.video_url = video_url;
    }

    pub fn mime_type(&mut self, mime_type: String) {
        self.mime_type = mime_type;
    }

    pub fn thumb_url(&mut self, thumb_url: String) {
        self.thumb_url = thumb_url;
    }

    pub fn title(&mut self, title: String) {
        self.title = title;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn video_width(&mut self, video_width: Option<isize>) {
        self.video_width = video_width;
    }

    pub fn video_height(&mut self, video_height: Option<isize>) {
        self.video_height = video_height;
    }

    pub fn video_duration(&mut self, video_duration: Option<isize>) {
        self.video_duration = video_duration;
    }

    pub fn description(&mut self, description: Option<String>) {
        self.description = description;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }

    pub fn input_message_content(&mut self, input_message_content: Option<InputMessageContent>) {
        self.input_message_content = input_message_content;
    }
}

impl InlineQueryResultAudio {
    pub fn new(type_field: String, id: String, audio_url: String, title: String) -> Self {
        Self {
            type_field,
            id,
            audio_url,
            title,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            performer: None,
            audio_duration: None,
            reply_markup: None,
            input_message_content: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn audio_url(&mut self, audio_url: String) {
        self.audio_url = audio_url;
    }

    pub fn title(&mut self, title: String) {
        self.title = title;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn performer(&mut self, performer: Option<String>) {
        self.performer = performer;
    }

    pub fn audio_duration(&mut self, audio_duration: Option<isize>) {
        self.audio_duration = audio_duration;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }

    pub fn input_message_content(&mut self, input_message_content: Option<InputMessageContent>) {
        self.input_message_content = input_message_content;
    }
}

impl InlineQueryResultVoice {
    pub fn new(type_field: String, id: String, voice_url: String, title: String) -> Self {
        Self {
            type_field,
            id,
            voice_url,
            title,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            voice_duration: None,
            reply_markup: None,
            input_message_content: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn voice_url(&mut self, voice_url: String) {
        self.voice_url = voice_url;
    }

    pub fn title(&mut self, title: String) {
        self.title = title;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn voice_duration(&mut self, voice_duration: Option<isize>) {
        self.voice_duration = voice_duration;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }

    pub fn input_message_content(&mut self, input_message_content: Option<InputMessageContent>) {
        self.input_message_content = input_message_content;
    }
}

impl InlineQueryResultDocument {
    pub fn new(
        type_field: String,
        id: String,
        title: String,
        document_url: String,
        mime_type: String,
    ) -> Self {
        Self {
            type_field,
            id,
            title,
            document_url,
            mime_type,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            description: None,
            reply_markup: None,
            input_message_content: None,
            thumb_url: None,
            thumb_width: None,
            thumb_height: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn title(&mut self, title: String) {
        self.title = title;
    }

    pub fn document_url(&mut self, document_url: String) {
        self.document_url = document_url;
    }

    pub fn mime_type(&mut self, mime_type: String) {
        self.mime_type = mime_type;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn description(&mut self, description: Option<String>) {
        self.description = description;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }

    pub fn input_message_content(&mut self, input_message_content: Option<InputMessageContent>) {
        self.input_message_content = input_message_content;
    }

    pub fn thumb_url(&mut self, thumb_url: Option<String>) {
        self.thumb_url = thumb_url;
    }

    pub fn thumb_width(&mut self, thumb_width: Option<isize>) {
        self.thumb_width = thumb_width;
    }

    pub fn thumb_height(&mut self, thumb_height: Option<isize>) {
        self.thumb_height = thumb_height;
    }
}

impl InlineQueryResultLocation {
    pub fn new(
        type_field: String,
        id: String,
        latitude: f64,
        longitude: f64,
        title: String,
    ) -> Self {
        Self {
            type_field,
            id,
            latitude,
            longitude,
            title,
            horizontal_accuracy: None,
            live_period: None,
            heading: None,
            proximity_alert_radius: None,
            reply_markup: None,
            input_message_content: None,
            thumb_url: None,
            thumb_width: None,
            thumb_height: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn latitude(&mut self, latitude: f64) {
        self.latitude = latitude;
    }

    pub fn longitude(&mut self, longitude: f64) {
        self.longitude = longitude;
    }

    pub fn title(&mut self, title: String) {
        self.title = title;
    }

    pub fn horizontal_accuracy(&mut self, horizontal_accuracy: Option<f64>) {
        self.horizontal_accuracy = horizontal_accuracy;
    }

    pub fn live_period(&mut self, live_period: Option<isize>) {
        self.live_period = live_period;
    }

    pub fn heading(&mut self, heading: Option<isize>) {
        self.heading = heading;
    }

    pub fn proximity_alert_radius(&mut self, proximity_alert_radius: Option<isize>) {
        self.proximity_alert_radius = proximity_alert_radius;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }

    pub fn input_message_content(&mut self, input_message_content: Option<InputMessageContent>) {
        self.input_message_content = input_message_content;
    }

    pub fn thumb_url(&mut self, thumb_url: Option<String>) {
        self.thumb_url = thumb_url;
    }

    pub fn thumb_width(&mut self, thumb_width: Option<isize>) {
        self.thumb_width = thumb_width;
    }

    pub fn thumb_height(&mut self, thumb_height: Option<isize>) {
        self.thumb_height = thumb_height;
    }
}

impl InlineQueryResultVenue {
    pub fn new(
        type_field: String,
        id: String,
        latitude: f64,
        longitude: f64,
        title: String,
        address: String,
    ) -> Self {
        Self {
            type_field,
            id,
            latitude,
            longitude,
            title,
            address,
            foursquare_id: None,
            foursquare_type: None,
            google_place_id: None,
            google_place_type: None,
            reply_markup: None,
            input_message_content: None,
            thumb_url: None,
            thumb_width: None,
            thumb_height: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn latitude(&mut self, latitude: f64) {
        self.latitude = latitude;
    }

    pub fn longitude(&mut self, longitude: f64) {
        self.longitude = longitude;
    }

    pub fn title(&mut self, title: String) {
        self.title = title;
    }

    pub fn address(&mut self, address: String) {
        self.address = address;
    }

    pub fn foursquare_id(&mut self, foursquare_id: Option<String>) {
        self.foursquare_id = foursquare_id;
    }

    pub fn foursquare_type(&mut self, foursquare_type: Option<String>) {
        self.foursquare_type = foursquare_type;
    }

    pub fn google_place_id(&mut self, google_place_id: Option<String>) {
        self.google_place_id = google_place_id;
    }

    pub fn google_place_type(&mut self, google_place_type: Option<String>) {
        self.google_place_type = google_place_type;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }

    pub fn input_message_content(&mut self, input_message_content: Option<InputMessageContent>) {
        self.input_message_content = input_message_content;
    }

    pub fn thumb_url(&mut self, thumb_url: Option<String>) {
        self.thumb_url = thumb_url;
    }

    pub fn thumb_width(&mut self, thumb_width: Option<isize>) {
        self.thumb_width = thumb_width;
    }

    pub fn thumb_height(&mut self, thumb_height: Option<isize>) {
        self.thumb_height = thumb_height;
    }
}

impl InlineQueryResultContact {
    pub fn new(type_field: String, id: String, phone_number: String, first_name: String) -> Self {
        Self {
            type_field,
            id,
            phone_number,
            first_name,
            last_name: None,
            vcard: None,
            reply_markup: None,
            input_message_content: None,
            thumb_url: None,
            thumb_width: None,
            thumb_height: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn phone_number(&mut self, phone_number: String) {
        self.phone_number = phone_number;
    }

    pub fn first_name(&mut self, first_name: String) {
        self.first_name = first_name;
    }

    pub fn last_name(&mut self, last_name: Option<String>) {
        self.last_name = last_name;
    }

    pub fn vcard(&mut self, vcard: Option<String>) {
        self.vcard = vcard;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }

    pub fn input_message_content(&mut self, input_message_content: Option<InputMessageContent>) {
        self.input_message_content = input_message_content;
    }

    pub fn thumb_url(&mut self, thumb_url: Option<String>) {
        self.thumb_url = thumb_url;
    }

    pub fn thumb_width(&mut self, thumb_width: Option<isize>) {
        self.thumb_width = thumb_width;
    }

    pub fn thumb_height(&mut self, thumb_height: Option<isize>) {
        self.thumb_height = thumb_height;
    }
}

impl InlineQueryResultGame {
    pub fn new(type_field: String, id: String, game_short_name: String) -> Self {
        Self {
            type_field,
            id,
            game_short_name,
            reply_markup: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn game_short_name(&mut self, game_short_name: String) {
        self.game_short_name = game_short_name;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }
}

impl InlineQueryResultCachedPhoto {
    pub fn new(type_field: String, id: String, photo_file_id: String) -> Self {
        Self {
            type_field,
            id,
            photo_file_id,
            title: None,
            description: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn photo_file_id(&mut self, photo_file_id: String) {
        self.photo_file_id = photo_file_id;
    }

    pub fn title(&mut self, title: Option<String>) {
        self.title = title;
    }

    pub fn description(&mut self, description: Option<String>) {
        self.description = description;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }

    pub fn input_message_content(&mut self, input_message_content: Option<InputMessageContent>) {
        self.input_message_content = input_message_content;
    }
}

impl InlineQueryResultCachedGif {
    pub fn new(type_field: String, id: String, gif_file_id: String) -> Self {
        Self {
            type_field,
            id,
            gif_file_id,
            title: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn gif_file_id(&mut self, gif_file_id: String) {
        self.gif_file_id = gif_file_id;
    }

    pub fn title(&mut self, title: Option<String>) {
        self.title = title;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }

    pub fn input_message_content(&mut self, input_message_content: Option<InputMessageContent>) {
        self.input_message_content = input_message_content;
    }
}

impl InlineQueryResultCachedMpeg4Gif {
    pub fn new(type_field: String, id: String, mpeg4_file_id: String) -> Self {
        Self {
            type_field,
            id,
            mpeg4_file_id,
            title: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn mpeg4_file_id(&mut self, mpeg4_file_id: String) {
        self.mpeg4_file_id = mpeg4_file_id;
    }

    pub fn title(&mut self, title: Option<String>) {
        self.title = title;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }

    pub fn input_message_content(&mut self, input_message_content: Option<InputMessageContent>) {
        self.input_message_content = input_message_content;
    }
}

impl InlineQueryResultCachedSticker {
    pub fn new(type_field: String, id: String, sticker_file_id: String) -> Self {
        Self {
            type_field,
            id,
            sticker_file_id,
            reply_markup: None,
            input_message_content: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn sticker_file_id(&mut self, sticker_file_id: String) {
        self.sticker_file_id = sticker_file_id;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }

    pub fn input_message_content(&mut self, input_message_content: Option<InputMessageContent>) {
        self.input_message_content = input_message_content;
    }
}

impl InlineQueryResultCachedDocument {
    pub fn new(type_field: String, id: String, title: String, document_file_id: String) -> Self {
        Self {
            type_field,
            id,
            title,
            document_file_id,
            description: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn title(&mut self, title: String) {
        self.title = title;
    }

    pub fn document_file_id(&mut self, document_file_id: String) {
        self.document_file_id = document_file_id;
    }

    pub fn description(&mut self, description: Option<String>) {
        self.description = description;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }

    pub fn input_message_content(&mut self, input_message_content: Option<InputMessageContent>) {
        self.input_message_content = input_message_content;
    }
}

impl InlineQueryResultCachedVideo {
    pub fn new(type_field: String, id: String, video_file_id: String, title: String) -> Self {
        Self {
            type_field,
            id,
            video_file_id,
            title,
            description: None,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn video_file_id(&mut self, video_file_id: String) {
        self.video_file_id = video_file_id;
    }

    pub fn title(&mut self, title: String) {
        self.title = title;
    }

    pub fn description(&mut self, description: Option<String>) {
        self.description = description;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }

    pub fn input_message_content(&mut self, input_message_content: Option<InputMessageContent>) {
        self.input_message_content = input_message_content;
    }
}

impl InlineQueryResultCachedVoice {
    pub fn new(type_field: String, id: String, voice_file_id: String, title: String) -> Self {
        Self {
            type_field,
            id,
            voice_file_id,
            title,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn voice_file_id(&mut self, voice_file_id: String) {
        self.voice_file_id = voice_file_id;
    }

    pub fn title(&mut self, title: String) {
        self.title = title;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }

    pub fn input_message_content(&mut self, input_message_content: Option<InputMessageContent>) {
        self.input_message_content = input_message_content;
    }
}

impl InlineQueryResultCachedAudio {
    pub fn new(type_field: String, id: String, audio_file_id: String) -> Self {
        Self {
            type_field,
            id,
            audio_file_id,
            caption: None,
            parse_mode: None,
            caption_entities: None,
            reply_markup: None,
            input_message_content: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn audio_file_id(&mut self, audio_file_id: String) {
        self.audio_file_id = audio_file_id;
    }

    pub fn caption(&mut self, caption: Option<String>) {
        self.caption = caption;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn caption_entities(&mut self, caption_entities: Option<Vec<MessageEntity>>) {
        self.caption_entities = caption_entities;
    }

    pub fn reply_markup(&mut self, reply_markup: Option<InlineKeyboardMarkup>) {
        self.reply_markup = reply_markup;
    }

    pub fn input_message_content(&mut self, input_message_content: Option<InputMessageContent>) {
        self.input_message_content = input_message_content;
    }
}

impl InputTextMessageContent {
    pub fn new(message_text: String) -> Self {
        Self {
            message_text,
            parse_mode: None,
            entities: None,
            disable_web_page_preview: None,
        }
    }

    pub fn message_text(&mut self, message_text: String) {
        self.message_text = message_text;
    }

    pub fn parse_mode(&mut self, parse_mode: Option<String>) {
        self.parse_mode = parse_mode;
    }

    pub fn entities(&mut self, entities: Option<Vec<MessageEntity>>) {
        self.entities = entities;
    }

    pub fn disable_web_page_preview(&mut self, disable_web_page_preview: Option<bool>) {
        self.disable_web_page_preview = disable_web_page_preview;
    }
}

impl InputLocationMessageContent {
    pub fn new(latitude: f64, longitude: f64) -> Self {
        Self {
            latitude,
            longitude,
            horizontal_accuracy: None,
            live_period: None,
            heading: None,
            proximity_alert_radius: None,
        }
    }

    pub fn latitude(&mut self, latitude: f64) {
        self.latitude = latitude;
    }

    pub fn longitude(&mut self, longitude: f64) {
        self.longitude = longitude;
    }

    pub fn horizontal_accuracy(&mut self, horizontal_accuracy: Option<f64>) {
        self.horizontal_accuracy = horizontal_accuracy;
    }

    pub fn live_period(&mut self, live_period: Option<isize>) {
        self.live_period = live_period;
    }

    pub fn heading(&mut self, heading: Option<isize>) {
        self.heading = heading;
    }

    pub fn proximity_alert_radius(&mut self, proximity_alert_radius: Option<isize>) {
        self.proximity_alert_radius = proximity_alert_radius;
    }
}

impl InputVenueMessageContent {
    pub fn new(latitude: f64, longitude: f64, title: String, address: String) -> Self {
        Self {
            latitude,
            longitude,
            title,
            address,
            foursquare_id: None,
            foursquare_type: None,
            google_place_id: None,
            google_place_type: None,
        }
    }

    pub fn latitude(&mut self, latitude: f64) {
        self.latitude = latitude;
    }

    pub fn longitude(&mut self, longitude: f64) {
        self.longitude = longitude;
    }

    pub fn title(&mut self, title: String) {
        self.title = title;
    }

    pub fn address(&mut self, address: String) {
        self.address = address;
    }

    pub fn foursquare_id(&mut self, foursquare_id: Option<String>) {
        self.foursquare_id = foursquare_id;
    }

    pub fn foursquare_type(&mut self, foursquare_type: Option<String>) {
        self.foursquare_type = foursquare_type;
    }

    pub fn google_place_id(&mut self, google_place_id: Option<String>) {
        self.google_place_id = google_place_id;
    }

    pub fn google_place_type(&mut self, google_place_type: Option<String>) {
        self.google_place_type = google_place_type;
    }
}

impl InputContactMessageContent {
    pub fn new(phone_number: String, first_name: String) -> Self {
        Self {
            phone_number,
            first_name,
            last_name: None,
            vcard: None,
        }
    }

    pub fn phone_number(&mut self, phone_number: String) {
        self.phone_number = phone_number;
    }

    pub fn first_name(&mut self, first_name: String) {
        self.first_name = first_name;
    }

    pub fn last_name(&mut self, last_name: Option<String>) {
        self.last_name = last_name;
    }

    pub fn vcard(&mut self, vcard: Option<String>) {
        self.vcard = vcard;
    }
}

impl ChosenInlineResult {
    pub fn new(result_id: String, from: User, query: String) -> Self {
        Self {
            result_id,
            from,
            query,
            location: None,
            inline_message_id: None,
        }
    }

    pub fn result_id(&mut self, result_id: String) {
        self.result_id = result_id;
    }

    pub fn from(&mut self, from: User) {
        self.from = from;
    }

    pub fn query(&mut self, query: String) {
        self.query = query;
    }

    pub fn location(&mut self, location: Option<Location>) {
        self.location = location;
    }

    pub fn inline_message_id(&mut self, inline_message_id: Option<String>) {
        self.inline_message_id = inline_message_id;
    }
}

impl LabeledPrice {
    pub fn new(label: String, amount: isize) -> Self {
        Self { label, amount }
    }

    pub fn label(&mut self, label: String) {
        self.label = label;
    }

    pub fn amount(&mut self, amount: isize) {
        self.amount = amount;
    }
}

impl Invoice {
    pub fn new(
        title: String,
        description: String,
        start_parameter: String,
        currency: String,
        total_amount: isize,
    ) -> Self {
        Self {
            title,
            description,
            start_parameter,
            currency,
            total_amount,
        }
    }

    pub fn title(&mut self, title: String) {
        self.title = title;
    }

    pub fn description(&mut self, description: String) {
        self.description = description;
    }

    pub fn start_parameter(&mut self, start_parameter: String) {
        self.start_parameter = start_parameter;
    }

    pub fn currency(&mut self, currency: String) {
        self.currency = currency;
    }

    pub fn total_amount(&mut self, total_amount: isize) {
        self.total_amount = total_amount;
    }
}

impl ShippingAddress {
    pub fn new(
        country_code: String,
        state: String,
        city: String,
        street_line1: String,
        street_line2: String,
        post_code: String,
    ) -> Self {
        Self {
            country_code,
            state,
            city,
            street_line1,
            street_line2,
            post_code,
        }
    }

    pub fn country_code(&mut self, country_code: String) {
        self.country_code = country_code;
    }

    pub fn state(&mut self, state: String) {
        self.state = state;
    }

    pub fn city(&mut self, city: String) {
        self.city = city;
    }

    pub fn street_line1(&mut self, street_line1: String) {
        self.street_line1 = street_line1;
    }

    pub fn street_line2(&mut self, street_line2: String) {
        self.street_line2 = street_line2;
    }

    pub fn post_code(&mut self, post_code: String) {
        self.post_code = post_code;
    }
}

impl OrderInfo {
    pub fn new() -> Self {
        Self {
            name: None,
            phone_number: None,
            email: None,
            shipping_address: None,
        }
    }

    pub fn name(&mut self, name: Option<String>) {
        self.name = name;
    }

    pub fn phone_number(&mut self, phone_number: Option<String>) {
        self.phone_number = phone_number;
    }

    pub fn email(&mut self, email: Option<String>) {
        self.email = email;
    }

    pub fn shipping_address(&mut self, shipping_address: Option<ShippingAddress>) {
        self.shipping_address = shipping_address;
    }
}

impl ShippingOption {
    pub fn new(id: String, title: String, prices: Vec<LabeledPrice>) -> Self {
        Self { id, title, prices }
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn title(&mut self, title: String) {
        self.title = title;
    }

    pub fn prices(&mut self, prices: Vec<LabeledPrice>) {
        self.prices = prices;
    }
}

impl SuccessfulPayment {
    pub fn new(
        currency: String,
        total_amount: isize,
        invoice_payload: String,
        telegram_payment_charge_id: String,
        provider_payment_charge_id: String,
    ) -> Self {
        Self {
            currency,
            total_amount,
            invoice_payload,
            telegram_payment_charge_id,
            provider_payment_charge_id,
            shipping_option_id: None,
            order_info: None,
        }
    }

    pub fn currency(&mut self, currency: String) {
        self.currency = currency;
    }

    pub fn total_amount(&mut self, total_amount: isize) {
        self.total_amount = total_amount;
    }

    pub fn invoice_payload(&mut self, invoice_payload: String) {
        self.invoice_payload = invoice_payload;
    }

    pub fn telegram_payment_charge_id(&mut self, telegram_payment_charge_id: String) {
        self.telegram_payment_charge_id = telegram_payment_charge_id;
    }

    pub fn provider_payment_charge_id(&mut self, provider_payment_charge_id: String) {
        self.provider_payment_charge_id = provider_payment_charge_id;
    }

    pub fn shipping_option_id(&mut self, shipping_option_id: Option<String>) {
        self.shipping_option_id = shipping_option_id;
    }

    pub fn order_info(&mut self, order_info: Option<OrderInfo>) {
        self.order_info = order_info;
    }
}

impl ShippingQuery {
    pub fn new(
        id: String,
        from: User,
        invoice_payload: String,
        shipping_address: ShippingAddress,
    ) -> Self {
        Self {
            id,
            from,
            invoice_payload,
            shipping_address,
        }
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn from(&mut self, from: User) {
        self.from = from;
    }

    pub fn invoice_payload(&mut self, invoice_payload: String) {
        self.invoice_payload = invoice_payload;
    }

    pub fn shipping_address(&mut self, shipping_address: ShippingAddress) {
        self.shipping_address = shipping_address;
    }
}

impl PreCheckoutQuery {
    pub fn new(
        id: String,
        from: User,
        currency: String,
        total_amount: isize,
        invoice_payload: String,
    ) -> Self {
        Self {
            id,
            from,
            currency,
            total_amount,
            invoice_payload,
            shipping_option_id: None,
            order_info: None,
        }
    }

    pub fn id(&mut self, id: String) {
        self.id = id;
    }

    pub fn from(&mut self, from: User) {
        self.from = from;
    }

    pub fn currency(&mut self, currency: String) {
        self.currency = currency;
    }

    pub fn total_amount(&mut self, total_amount: isize) {
        self.total_amount = total_amount;
    }

    pub fn invoice_payload(&mut self, invoice_payload: String) {
        self.invoice_payload = invoice_payload;
    }

    pub fn shipping_option_id(&mut self, shipping_option_id: Option<String>) {
        self.shipping_option_id = shipping_option_id;
    }

    pub fn order_info(&mut self, order_info: Option<OrderInfo>) {
        self.order_info = order_info;
    }
}

impl PassportData {
    pub fn new(data: Vec<EncryptedPassportElement>, credentials: EncryptedCredentials) -> Self {
        Self { data, credentials }
    }

    pub fn data(&mut self, data: Vec<EncryptedPassportElement>) {
        self.data = data;
    }

    pub fn credentials(&mut self, credentials: EncryptedCredentials) {
        self.credentials = credentials;
    }
}

impl PassportFile {
    pub fn new(
        file_id: String,
        file_unique_id: String,
        file_size: isize,
        file_date: isize,
    ) -> Self {
        Self {
            file_id,
            file_unique_id,
            file_size,
            file_date,
        }
    }

    pub fn file_id(&mut self, file_id: String) {
        self.file_id = file_id;
    }

    pub fn file_unique_id(&mut self, file_unique_id: String) {
        self.file_unique_id = file_unique_id;
    }

    pub fn file_size(&mut self, file_size: isize) {
        self.file_size = file_size;
    }

    pub fn file_date(&mut self, file_date: isize) {
        self.file_date = file_date;
    }
}

impl EncryptedPassportElement {
    pub fn new(type_field: String, hash: String) -> Self {
        Self {
            type_field,
            hash,
            data: None,
            phone_number: None,
            email: None,
            files: None,
            front_side: None,
            reverse_side: None,
            selfie: None,
            translation: None,
        }
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn hash(&mut self, hash: String) {
        self.hash = hash;
    }

    pub fn data(&mut self, data: Option<String>) {
        self.data = data;
    }

    pub fn phone_number(&mut self, phone_number: Option<String>) {
        self.phone_number = phone_number;
    }

    pub fn email(&mut self, email: Option<String>) {
        self.email = email;
    }

    pub fn files(&mut self, files: Option<Vec<PassportFile>>) {
        self.files = files;
    }

    pub fn front_side(&mut self, front_side: Option<PassportFile>) {
        self.front_side = front_side;
    }

    pub fn reverse_side(&mut self, reverse_side: Option<PassportFile>) {
        self.reverse_side = reverse_side;
    }

    pub fn selfie(&mut self, selfie: Option<PassportFile>) {
        self.selfie = selfie;
    }

    pub fn translation(&mut self, translation: Option<Vec<PassportFile>>) {
        self.translation = translation;
    }
}

impl EncryptedCredentials {
    pub fn new(data: String, hash: String, secret: String) -> Self {
        Self { data, hash, secret }
    }

    pub fn data(&mut self, data: String) {
        self.data = data;
    }

    pub fn hash(&mut self, hash: String) {
        self.hash = hash;
    }

    pub fn secret(&mut self, secret: String) {
        self.secret = secret;
    }
}

impl PassportElementErrorDataField {
    pub fn new(
        source: String,
        type_field: String,
        field_name: String,
        data_hash: String,
        message: String,
    ) -> Self {
        Self {
            source,
            type_field,
            field_name,
            data_hash,
            message,
        }
    }

    pub fn source(&mut self, source: String) {
        self.source = source;
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn field_name(&mut self, field_name: String) {
        self.field_name = field_name;
    }

    pub fn data_hash(&mut self, data_hash: String) {
        self.data_hash = data_hash;
    }

    pub fn message(&mut self, message: String) {
        self.message = message;
    }
}

impl PassportElementErrorFrontSide {
    pub fn new(source: String, type_field: String, file_hash: String, message: String) -> Self {
        Self {
            source,
            type_field,
            file_hash,
            message,
        }
    }

    pub fn source(&mut self, source: String) {
        self.source = source;
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn file_hash(&mut self, file_hash: String) {
        self.file_hash = file_hash;
    }

    pub fn message(&mut self, message: String) {
        self.message = message;
    }
}

impl PassportElementErrorReverseSide {
    pub fn new(source: String, type_field: String, file_hash: String, message: String) -> Self {
        Self {
            source,
            type_field,
            file_hash,
            message,
        }
    }

    pub fn source(&mut self, source: String) {
        self.source = source;
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn file_hash(&mut self, file_hash: String) {
        self.file_hash = file_hash;
    }

    pub fn message(&mut self, message: String) {
        self.message = message;
    }
}

impl PassportElementErrorSelfie {
    pub fn new(source: String, type_field: String, file_hash: String, message: String) -> Self {
        Self {
            source,
            type_field,
            file_hash,
            message,
        }
    }

    pub fn source(&mut self, source: String) {
        self.source = source;
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn file_hash(&mut self, file_hash: String) {
        self.file_hash = file_hash;
    }

    pub fn message(&mut self, message: String) {
        self.message = message;
    }
}

impl PassportElementErrorFile {
    pub fn new(source: String, type_field: String, file_hash: String, message: String) -> Self {
        Self {
            source,
            type_field,
            file_hash,
            message,
        }
    }

    pub fn source(&mut self, source: String) {
        self.source = source;
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn file_hash(&mut self, file_hash: String) {
        self.file_hash = file_hash;
    }

    pub fn message(&mut self, message: String) {
        self.message = message;
    }
}

impl PassportElementErrorFiles {
    pub fn new(
        source: String,
        type_field: String,
        file_hashes: Vec<String>,
        message: String,
    ) -> Self {
        Self {
            source,
            type_field,
            file_hashes,
            message,
        }
    }

    pub fn source(&mut self, source: String) {
        self.source = source;
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn file_hashes(&mut self, file_hashes: Vec<String>) {
        self.file_hashes = file_hashes;
    }

    pub fn message(&mut self, message: String) {
        self.message = message;
    }
}

impl PassportElementErrorTranslationFile {
    pub fn new(source: String, type_field: String, file_hash: String, message: String) -> Self {
        Self {
            source,
            type_field,
            file_hash,
            message,
        }
    }

    pub fn source(&mut self, source: String) {
        self.source = source;
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn file_hash(&mut self, file_hash: String) {
        self.file_hash = file_hash;
    }

    pub fn message(&mut self, message: String) {
        self.message = message;
    }
}

impl PassportElementErrorTranslationFiles {
    pub fn new(
        source: String,
        type_field: String,
        file_hashes: Vec<String>,
        message: String,
    ) -> Self {
        Self {
            source,
            type_field,
            file_hashes,
            message,
        }
    }

    pub fn source(&mut self, source: String) {
        self.source = source;
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn file_hashes(&mut self, file_hashes: Vec<String>) {
        self.file_hashes = file_hashes;
    }

    pub fn message(&mut self, message: String) {
        self.message = message;
    }
}

impl PassportElementErrorUnspecified {
    pub fn new(source: String, type_field: String, element_hash: String, message: String) -> Self {
        Self {
            source,
            type_field,
            element_hash,
            message,
        }
    }

    pub fn source(&mut self, source: String) {
        self.source = source;
    }

    pub fn type_field(&mut self, type_field: String) {
        self.type_field = type_field;
    }

    pub fn element_hash(&mut self, element_hash: String) {
        self.element_hash = element_hash;
    }

    pub fn message(&mut self, message: String) {
        self.message = message;
    }
}

impl Game {
    pub fn new(title: String, description: String, photo: Vec<PhotoSize>) -> Self {
        Self {
            title,
            description,
            photo,
            text: None,
            text_entities: None,
            animation: None,
        }
    }

    pub fn title(&mut self, title: String) {
        self.title = title;
    }

    pub fn description(&mut self, description: String) {
        self.description = description;
    }

    pub fn photo(&mut self, photo: Vec<PhotoSize>) {
        self.photo = photo;
    }

    pub fn text(&mut self, text: Option<String>) {
        self.text = text;
    }

    pub fn text_entities(&mut self, text_entities: Option<Vec<MessageEntity>>) {
        self.text_entities = text_entities;
    }

    pub fn animation(&mut self, animation: Option<Animation>) {
        self.animation = animation;
    }
}

impl GameHighScore {
    pub fn new(position: isize, user: User, score: isize) -> Self {
        Self {
            position,
            user,
            score,
        }
    }

    pub fn position(&mut self, position: isize) {
        self.position = position;
    }

    pub fn user(&mut self, user: User) {
        self.user = user;
    }

    pub fn score(&mut self, score: isize) {
        self.score = score;
    }
}
